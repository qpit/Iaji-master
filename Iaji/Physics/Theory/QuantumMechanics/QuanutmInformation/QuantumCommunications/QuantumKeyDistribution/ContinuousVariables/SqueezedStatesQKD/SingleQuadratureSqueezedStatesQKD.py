"""
@author: Iyad Suleiman
@Creation date: 20210908  

This file defines classes that describe a QKD system, specifically 
a QKD system based on the Gaussian modulation of the squeezed quadrature of a bosonic field.

The system is modeled using the purification approach to calculate the asymptotic secret key rate, 
thereby assuming no particular attack from by the eavesdropper.
To simply do so and avoid the need for information about additional modes,
currently no trusted loss or noise is considered, therefore attributing every source of loss or noise in the system to 
the eavesdropper.
"""

#%%
#Imports
import numpy as np
import sympy
sympy.init_printing()
from Iaji.Physics.Theory.QuanutmInformation import QuantumInformationUtilities as QIUtils
from quik.qip.nmodes import covariancematrix
from quik.qip.nmodes import vacuum
from quik.qip.nmodes_symbolic import Vacuum as vacuum_symbolic
from quik.qip.nmodes_symbolic import CovarianceMatrix as CovarianceMatrix_symbolic
#%%
class Parameter:
    """
    This class describes a generic parameter. A parameter is described by the following properties:
        -name
        
        -symbol
        
        -value: the numerical value of the parameter
        
        -expression_symbolic: a symbolic mathematical expression of the parameter, in terms of other symbols
       
        -expression_numeric: a function that allows numerical evaluation of the parameter's value form numerical input parameters
    """
    
    def __init__(self, name='x', value=None, real=True, nonnegative=True):
        self.name = name
        self.value = value
        self.symbol = sympy.symbols(names=name, real=real, nonnegative=nonnegative)
        self.expression_symbolic = None
        self.expression_numeric = None
#%%
class QKDParameters:
    """
    This class describes the parameters of the QKD system:
        
    - n: real, > 0.

         mean photon number of the thermal state generated by Gaussian modulation of a displaced vacuum state, at the output of the squeezer
    - V_s$ real, > 0.

        variance of the squeezed quadrature of the unmodulated signal, at the output of the squeezer

    - T_A: real, [0, 1]
        Auxiliary parameter, equal to R_{Tx}*\tau_A
    
    - T_q: real, [0, 1]
        Auxiliary parameter, equal to \tau_{Rx}*R_{Rx}*tau_q
    
    - T_p: real, [0, 1]
        Auxiliary parameter, equal to \tau_{Rx}*(1-R_{Rx})*tau_p
    
    - T_b2b: real, [0, 1]
        power transmission efficiency from the single-mode squeezer to the input of the receiver's beam splitter
    """      
    
    def __init__(self, T_A=None, T_q=None, T_p=None, T_b2b=None, V_s=None, n=None):
        self.T_A = Parameter(name='T_A', value=T_b2b)
        self.T_q = Parameter(name='T_q', value=T_q)
        self.T_p = Parameter(name='T_p', value=T_p)
        self.T_b2b = Parameter(name='T_{b2b}', value=T_b2b)
        self.V_s = Parameter(name='V_s', value=V_s)
        self.n = Parameter(name='n', value=n)
        
    def toList(self):
        """
        This function returns a list of all the QKD parameters, ordered by their name
        """
        dictionary = vars(self)
        dictionary_sorted = dict(sorted(dictionary.items(), key=lambda item: item[0]))
        return list(dictionary_sorted.values())  
    
    def toDict(self, attribute='name'):
        """
        This function returns a dictionary of all the QKD parameters, with keys given
        by the parameter attribute 'attribute'.
        
        INPUTS
        ------------------
        attribute : string
            The attribute used as key to the dictionary. Refer to Parameter class for the attributes.
        """
        
        parameters = self.toList() 
        attributes = [getattr(p, attribute) for p in parameters]
        return dict(zip(attributes, parameters))
        

#%%
class QKDPrepareAndMeasureCovariances:
    """
    This class defines the entries of the prepare & measure covariance
    matrix of the QKD system, relevant to experimental parameter estimation:
        
        - V^{(Tx)}_q: variance of the q quadrature detected at homodomdyne detector Tx

        - V^{(Rx-q)}_q: variance of the q quadrature detected at homodomdyne detector Rx-q

        - V^{(Rx-p)}_p: variance of the p quadrature detected at homodomdyne detector Rx-p

        - V^{(Rx-p)}_{p(nomod)}: variance of the p quadrature detected at homodomdyne detector Rx-p without modulation ($n=0$)

        - C^{(Tx/Rx-q)}_q: covariance between the q quadratures detected at homodyne detectors Tx and Rx-q

        - C^{(mod/Rx-p)}_p: covariance between the p quadrature detected at homodyne detector Rx-p and the generated QKD symbols

    """

    def __init__(self, V_q_Tx=None, V_q_Rx_q=None, V_q_Rx_p=None, V_p_Rx_p=None,\
                 V_p_nomod_Rx_p=None, C_q_Tx_Rx_q=None, C_q_Tx_Rx_p=None,\
                 C_p_mod_Rx_p=None):
        self.V_q_Tx = Parameter(name='V^{(Tx)}_q', value=V_q_Tx)
        self.V_q_Rx_q = Parameter(name='V^{(Rx-q)}_q', value=V_q_Rx_q)
        self.V_p_Rx_p = Parameter(name='V^{(Rx-p)}_p', value=V_p_Rx_p)
        self.V_p_nomod_Rx_p = Parameter(name='V^{(Rx-p)}_{p(nomod)}', value=V_p_nomod_Rx_p)
        self.C_q_Tx_Rx_q = Parameter(name='C^{(Tx/Rx-q)}_q', value=C_q_Tx_Rx_q )
        self.C_p_mod_Rx_p = Parameter(name='C^{(mod/Rx-p)}_p', value=C_p_mod_Rx_p)
    
    def toList(self):
        """
        This function returns a list of all the QKD parameters, ordered by their name
        """
        dictionary = vars(self)
        dictionary_sorted = dict(sorted(dictionary.items(), key=lambda item: item[0]))
        return list(dictionary_sorted.values())     
    
#%%+
class QKDSystem:
    """
    This class describes a QKD system, which has the following properties:
        - A set of QKD parameters
        - A prepare & measure covariance matrix (quantum mechanical and classical)
        - An entanglement-based covariance matrix
        - An error correction efficiency
        - A set of experimentally measured covariances, i.e., entries of the prepare & measure classical covariance matrix
        - A secret key rate
    
    The class allows to perform the following tasks:
        - Compute the covariance matrices associated to the system, given QKD parameters (symbolically and numerically)
        - Perform parameter estimation (symbolically and numerically)
        - Estimate the secret key rate (numerically)
        
    The vacuum quadrature variance is assumed to be equal to 1. All quadrature covariances are 
    normalized to the vacuum quadrature variance.
    """    
    
    def __init__(self, parameters=QKDParameters(), covariances_PM=QKDPrepareAndMeasureCovariances(), \
                 error_correction_efficiency=1):
        self.parameters = parameters #QKD parameters
        self.covariances_PM = covariances_PM #prepare and measure covariances
        self.covariances_PM_b2b = QKDPrepareAndMeasureCovariances() #prepare and measure covariances, in the back-to-back configuration
        
        self.covariance_matrix_EB = Parameter(name='\Sigma_{EB}', value=None, nonnegative=False) #entanglement-based covariance matrix
        
        self.beta = Parameter(name='\\beta') #error correction efficiency [adimensional, in [0, 1]]
        self.secret_key_rate = Parameter(name='R', real=True, nonnegative=False) #secret key rate [bit/symbol]
         
        #Construct a set of simplified prepare & measure covariances, derived by hand
        self.covariances_PM_b2b = QKDPrepareAndMeasureCovariances()
        #Assign symbolic and numeric expressions
        T_A = self.parameters.T_A.symbol
        T_q = self.parameters.T_q.symbol
        T_p = self.parameters.T_p.symbol
        T_b2b = self.parameters.T_b2b.symbol
        V_s = self.parameters.V_s.symbol
        n = self.parameters.n.symbol
        input_parameter_names = ['T_A', 'T_q', 'T_p', 'T_b2b', 'V_s', 'n']
        input_parameter_names.sort()
        """Fill in the expressions of the Prepare & Measure covariance matrix
        of the shared state between the trusted parties in a back-to-back (b2b)
        configuration, i.e., in the absence of a quantum channel. The expressions
        can be used to estimate the parameters needed 
        to construct the entanglement-based covariance matrix and estimate the 
        asymptotic secret key rate. 
        Such expressions were calculated by hand in my notes
        """
        self.covariances_PM_b2b.V_q_Tx.expression_symbolic = T_A*(1/V_s-1) + 1
        self.covariances_PM_b2b.V_q_Tx.expression_numeric = sympy.lambdify(input_parameter_names, fromNamesToVariables(str(self.covariances_PM_b2b.V_q_Tx.expression_symbolic)))
        
        self.covariances_PM_b2b.V_q_Rx_q.expression_symbolic = T_b2b*T_q*(1/V_s-1) + 1
        self.covariances_PM_b2b.V_q_Rx_q.expression_numeric = sympy.lambdify(input_parameter_names, fromNamesToVariables(str(self.covariances_PM_b2b.V_q_Rx_q.expression_symbolic)))
        
        self.covariances_PM_b2b.V_p_Rx_p.expression_symbolic = T_b2b*T_p*(V_s+2*n-1) + 1
        self.covariances_PM_b2b.V_p_Rx_p.expression_numeric = sympy.lambdify(input_parameter_names, fromNamesToVariables(str(self.covariances_PM_b2b.V_p_Rx_p.expression_symbolic)))

        
        self.covariances_PM_b2b.V_p_nomod_Rx_p.expression_symbolic = self.covariances_PM_b2b.V_p_Rx_p.expression_symbolic.subs([(n, 0)])
        self.covariances_PM_b2b.V_p_nomod_Rx_p.expression_numeric = sympy.lambdify(input_parameter_names, fromNamesToVariables(str(self.covariances_PM_b2b.V_p_nomod_Rx_p.expression_symbolic)))

        self.covariances_PM_b2b.C_p_mod_Rx_p.expression_symbolic = sympy.sqrt(T_b2b*T_p)*2*n
        self.covariances_PM_b2b.C_p_mod_Rx_p.expression_numeric = sympy.lambdify(input_parameter_names, fromNamesToVariables(str(self.covariances_PM_b2b.C_p_mod_Rx_p.expression_symbolic)))
        
    
    #To be corrected
    def computeCovarianceMatrixEB(self, form='symbolic', print_warnings=False):
        """
        This function constructs the entanglement-based covariance matrix of the 
        shared state between Alice and Bob, using the purification assumption.
        
        INPUTS
        ----------
        form : string
            'symbolic' or 'numeric'
        print_warnings : boolean
            If True, sanity check warnings on the covariance matrix are printed 
            after the calculation.
             
        OUTPUTS:
        -------
        CM : 2D array-like of float
            The entanglement-based covariance matrix. The modes of the field are ordered as follows:        
                1. A: signal mode at Alice
                2. B: signal mode at Bob before homodyne detection
        """
        #------------------------------------------
        attribute = 'symbol'*(form=='symbolic') + 'value'*(form=='numeric')
        [T_A, T_q, T_p, V_s, n, V_q_Rx_q, V_p_Rx_p, C_q_Tx_Rx_q, C_p_mod_Rx_p] = \
        [getattr(self.parameters.T_A, attribute), getattr(self.parameters.T_q, attribute),\
         getattr(self.parameters.T_p, attribute),\
         getattr(self.parameters.V_s, attribute), getattr(self.parameters.n, attribute),\
         getattr(self.covariances_PM.V_q_Rx_q, attribute), getattr(self.covariances_PM.V_p_Rx_p, attribute),\
         getattr(self.covariances_PM.C_q_Tx_Rx_q, attribute), getattr(self.covariances_PM.C_p_mod_Rx_p, attribute)] 
        if form=='symbolic':     
            CM = vacuum_symbolic(2)
        else:
            CM = vacuum(2)
        CM[0, 0] = V_s + 2*n
        CM[1, 1] = 1/V_s
        CM[2, 2] = T_p/T_q*(V_q_Rx_q - 1) + 1
        CM[3, 3] = (V_p_Rx_p - 1)/T_p + 1
        if form=='symbolic':
            CM[2, 0] = CM[0, 2] = C_q_Tx_Rx_q/sympy.sqrt(T_A*T_q)
            CM[1, 3] = CM[3, 1] = C_p_mod_Rx_p/sympy.sqrt(T_p)
            CM = CovarianceMatrix_symbolic(CM)
            setattr(self.covariance_matrix_EB, attribute, CM)
        else:
            CM[2, 0] = CM[0, 2] = C_q_Tx_Rx_q/(T_A*T_q)**0.5
            CM[1, 3] = CM[3, 1] = C_p_mod_Rx_p/(T_p)**0.5
            CM = covariancematrix(CM)
            setattr(self.covariance_matrix_EB, attribute, CM)
        return CM
    
    def computeKeyRate(self, form='numeric', print_warnings=False):
        """
        This function calculates the secret key rate from the entanglement-based covariance matrix.
        
        INPUTS
        ----------
        form : string
            'symbolic' or 'numeric'
        print_warnings: boolean
            If 'True', the function will print eventual warnings regarding the calculations. 
        
        OUTPUTS:
        -------
        The value of the secret key rate of the system : float 
        """
        attribute = 'symbol'*(form=='symbolic') + 'value'*(form=='numeric')
        #Entanglement-based covariance matrix
        CM_EB = self.computeCovarianceMatrixEB(form=form)
        #Covariance matrix conditioned on homodyne detection on the modulated quadrature
        CM_EB_HD_B = CM_EB.homodyne_detection(measured_mode=2, measured_quadrature='p')
        #Mutual information
        I_AB = QIUtils.mutualInformation(variance_1=CM_EB[0, 0], \
                                         variance_2=2*getattr(self.parameters.n, attribute), \
                                         covariance=CM_EB[1, 3])
        #Holevo information
        X_EB = QIUtils.VonNeumannEntropy(CM_EB) - QIUtils.VonNeumannEntropy(CM_EB_HD_B)
        R = self.beta.symbol*I_AB - X_EB
        #Key rate
        setattr(self.secret_key_rate, attribute, R)
        return R

        
    def estimateParameters(self, parameter_names=None, covariance_names = None, \
                           form='symbolic'):
        """
        This function performs parameter estimation of the parameters specified by
        
        Parameters
        ----------
        parameter_names : array-like of string
            The names of the parameters to be estimated, in variables format (e.g., ['eta'])
        covariance_names : array-like of string
            The names of the quadrature covariances from which the parameters are to be estimated, in variable format (e.g., ['V_q_Tx'])
        mode : string
            'symbolc' 'numeric'. The default is 'symbolic'.
        minimal : boolean
            If True, then parameter estimation is performed by considering the simplified
            expressions for the prepare & measure covariances, where the trusted losses are
            grouped into T_Tx, T_A, T_p and T_q.

        Returns
        -------
        None.

        """

        #Load the target parameters
        if parameter_names is None:
            raise ParameterEstimationError('No parameters were specified.')  
        equations_specified = covariance_names is not None
        #Load the prepare & measure covariances as parameters
        parameter_names.sort()
        covariance_names.sort()
        parameters = [getattr(self.parameters, name) for name in parameter_names]
        #Load the known parameteres
        known_parameter_names = [name for name in list(vars(self.parameters).keys()) if name not in parameter_names]
        known_parameter_names.sort()
        known_parameters = [getattr(self.parameters, name) for name in known_parameter_names]
        analytical_expression_missing = sum([p.expression_symbolic is None for p in parameters]) > 0
        #Check for possible errors in the input
        if not(equations_specified) and analytical_expression_missing:
            raise ParameterEstimationError("Analytical expressions of the parameters to be estimated are not available, but prepare & measure covariances were not specified."\
                                           +"\n You need to specify the covariances which parameters are estimated from.")    
        covariances= [getattr(self.covariances_PM_b2b, name) for name in covariance_names]
        #Symbolic parameter estimation 
        if form=='symbolic':
            #Set up the system of equations for estimating parameters
            system = []
            for covariance in covariances:
                system.append(sympy.Eq(covariance.expression_symbolic, covariance.symbol))
            system = tuple(system)
            parameter_symbols = [p.symbol for p in parameters]
            #Solve the system of equations
            try:
                solutions = sympy.solve(system, tuple(parameter_symbols), dict=True)
                solutions = solutions[0]
            except:
                raise ParameterEstimationError('No solution was found')
            #Set the symbolic expressions into the QKD system
            for solution_symbol in list(solutions.keys()):
                parameter = [p for p in parameters if p.name==solution_symbol.name][0]
                parameter.expression_symbolic = solutions[solution_symbol]
                parameter.expression_numeric = sympy.lambdify(known_parameter_names+covariance_names, fromNamesToVariables(str(solutions[solution_symbol])))  
        else: 
            if analytical_expression_missing:
                self.estimateParameters(parameter_names=parameter_names, covariance_names=covariance_names, form='symbolic')
            #Load the known parameters as symbols or values
            known_parameters = [p.value for p in known_parameters]
            #Load the prepare & measure covariances as symbols or values
            covariances = [c.value for c in covariances]
            for parameter in parameters:
                parameter.value = parameter.expression_numeric(*(known_parameters+covariances))
                        
#%%    
def fromNamesToVariables(string_symbols):
    """
    This function converts a string containing a symbolic expression
    into a string corresponding to the same Python expression with names of variables. 
    """
    return string_symbols.replace('^{(', '_').replace(')}', '').replace('Tx/', 'Tx_')\
            .replace('mod/', 'mod_')\
            .replace('{', '').replace('}', '').replace('Rx-', 'Rx_').replace('\\', '')\
            .replace('Tx_q', 'q_Tx').replace('Rx_q_q', 'q_Rx_q').replace('Rx_p_q', 'q_Rx_p')\
            .replace('Rx_p_p', 'p_Rx_p').replace('Rx_p(nomod', 'nomod_Rx_p')\
            .replace('mod_p', 'p_mod')   
#%%
#Define exceptions
class ParameterEstimationError(Exception):
    def __init__(self, error_message):
        print(error_message)
        