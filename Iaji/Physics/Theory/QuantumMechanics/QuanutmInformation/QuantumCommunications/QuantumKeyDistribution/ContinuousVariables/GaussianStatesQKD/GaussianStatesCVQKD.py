"""
This file defines classes that describe a fully-Gaussian CVQKD system, where
the p quadrature is squeezed, both p and q are modulated according to a Gaussian distribution
and the receiver performs a generally asymmetric and simultaneous homodyne detection of
q and p. 
"""

#%%
#Imports
import numpy as np
import sympy
sympy.init_printing()
from Iaji.Physics.Theory.QuanutmInformation import QuantumInformationUtilities as QIUtils
from quik.qip.nmodes import vacuum
from quik.qip.nmodes_symbolic import Vacuum as vacuum_symbolic
from quik.qip.nmodes_symbolic import CovarianceMatrix as CovarianceMatrix_symbolic
from quik.qip.nmodes import covariancematrix as CovarianceMatrix
#%%
print_separator = "---------------------------------------------"
#%%
class Parameter:
    """
    This class describes a generic parameter. A parameter is described by the following properties:
        -name
        
        -symbol
        
        -value: the numerical value of the parameter
        
        -expression_symbolic: a symbolic mathematical expression of the parameter, in terms of other symbols
       
        -expression_numeric: a function that allows numerical evaluation of the parameter's value form numerical input parameters
    """
    
    def __init__(self, name='x', value=None, real=True, nonnegative=True):
        self.name = name
        self.value = value
        self.symbol = sympy.symbols(names=name, real=real, nonnegative=nonnegative)
        self.expression_symbolic = None
        self.expression_numeric = None
#%%
class QKDParameters:
    """
    This class describes the parameters of the QKD system:
        
    - n_q, n_p: real, > 0.

         mean photon number of the thermal state generated by Gaussian modulation of a displaced vacuum state along quadratures q and p,
         
    - V_s$ real, > 0.

        variance of the squeezed quadrature of the unmodulated signal

    - n_c: real, > 0

        mean photon number of the excess thermal noise, at the input of a thermal-lossy channel 
        
    - T_A: real, [0, 1]
        
        Power transmission efficiency of the transmitter
    
    - \eta: real, [0, 1]

        power transmission efficiency of the quantum channel.

    - T_{B}: real, [0, 1]

        power transmission efficiency of the receiver, besides the measurement beam splitter
    
    - R_{A} : real,  [0, 1]
    
        power reflectivity of the transmitter's beam splitter in the entanglement-based protocol
    
    - R_{B}: real, [0, 1]

        power reflectivity of the receiver's beam splitter.
        
    - \sigma_{\phi_{A}}: real, > 0
        standard deviation of the Gaussian phase noise from the transmitter's local oscillaltor
        
    - \sigma_{\phi_{B}}: real, > 0
        standard deviation of the Gaussian phase noise from the receiver's local oscillaltor
    """      
    
    def __init__(self, T_A=1, eta=1, R_B=0.5, V_s=1, \
                 n_q=0, n_p=0, n_c=0, sigma_phi_A=0, sigma_phi_B=0):
        self.T_A = Parameter(name='T_A', value=T_A)
        self.eta = Parameter(name='\\eta', value=eta)
        self.R_B = Parameter(name='R_B', value=R_B)
        self.V_s = Parameter(name='V_s', value=V_s)     
        self.n_q = Parameter(name='n_q', value=n_q)
        self.n_p = Parameter(name='n_p', value=n_p)
        self.n_c = Parameter(name='n_c', value=n_c)
        self.sigma_phi_A = Parameter(name='\\sigma_{\\phi_A}', value=sigma_phi_A)
        self.sigma_phi_B = Parameter(name='\\sigma_{\\phi_B}', value=sigma_phi_B) 
        #Define auxiliary parameters used for minimal complete parameter estimation
        #Transmission efficiency from the output of the channel to the input of homodyne detector Rx-q
    def toList(self):
        """
        This function returns a list of all the QKD parameters, ordered by their name
        """
        dictionary = vars(self)
        dictionary_sorted = dict(sorted(dictionary.items(), key=lambda item: item[0]))
        return list(dictionary_sorted.values())  
    
    def toDict(self, attribute='name'):
        """
        This function returns a dictionary of all the QKD parameters, with keys given
        by the parameter attribute 'attribute'.
        
        INPUTS
        ------------------
        attribute : string
            The attribute used as key to the dictionary. Refer to Parameter class for the attributes.
        """
        
        parameters = self.toList() 
        attributes = [getattr(p, attribute) for p in parameters]
        return dict(zip(attributes, parameters))
        

#%%
class QKDPrepareAndMeasureCovariances:
    """
    This class defines the entries of the prepare & measure covariance
    matrix of the QKD system, relevant to experimental parameter estimation:
        
        - V_{q_A}: variance of the q quadrature detected at homodomdyne detector Tx

        - V_{q_B}: variance of the q quadrature detected at homodomdyne detector Rx-q

        - V_{p_B}: variance of the p quadrature detected at homodomdyne detector Rx-p

        - V_{p_B(nomod)}: variance of the p quadrature detected at homodomdyne detector Rx-p without modulation ($n_q=0$)

        - V_{q_B(nomod)}: variance of the q quadrature detected at homodomdyne detector Rx-q without modulation ($n_p=0$)

        - C_p: covariance between the p quadrature detected at homodyne detector Rx-p and the corresponding generated QKD symbols

        - C_q: covariance between the q quadrature detected at homodyne detector Rx-q and the corresponding generated QKD symbols
    """

    def __init__(self, V_q_A=None, V_q_B=None, V_p_B=None, V_p_B_nomod=None, V_q_B_nomod=None, C_p=None, C_q=None):
        self.V_q_B = Parameter(name='V_{q_B}', value=V_q_B)
        self.V_p_B = Parameter(name='V_{p_B}', value=V_p_B)
        self.V_p_B_nomod = Parameter(name='V_{p_B(nomod)}', value=V_p_B_nomod)
        self.V_q_B_nomod = Parameter(name='B_{q_B(nomod)}', value=V_q_B_nomod)
        self.C_q = Parameter(name='C_q', value=C_q)
        self.C_p = Parameter(name='C_p', value=C_p)
        
    def toList(self):
        """
        This function returns a list of all the QKD parameters, ordered by their name
        """
        dictionary = vars(self)
        dictionary_sorted = dict(sorted(dictionary.items(), key=lambda item: item[0]))
        return list(dictionary_sorted.values())     
    
#%%+
class QKDSystem:
    """
    This class describes a QKD system, which has the following properties:
        - A set of QKD parameters
        - A prepare & measure covariance matrix (quantum mechanical and classical)
        - An entanglement-based covariance matrix
        - An error correction efficiency
        - A set of experimentally measured covariances, i.e., entries of the prepare & measure classical covariance matrix
        - A secret key rate
    
    The class allows to perform the following tasks:
        - Compute the covariance matrices associated to the system, given QKD parameters (symbolically and numerically)
        - Perform parameter estimation (symbolically and numerically)
        - Estimate the secret key rate (numerically)
        
    The vacuum quadrature variance is assumed to be equal to 1. All quadrature covariances are 
    normalized to the vacuum quadrature variance.
    """    
    
    def __init__(self, parameters=QKDParameters(), covariances_PM=QKDPrepareAndMeasureCovariances(), \
                 error_correction_efficiency=1):
        self.parameters = parameters #QKD parameters
        self.covariances_PM = covariances_PM #prepare and measure covariances
        self.channel = None
        
        self.covariance_matrix_PM = Parameter(name='\Sigma_{PM}', value=None, nonnegative=False) #entanglement-based covariance matrix
       # self.computeCovarianceMatrixPM()
        
        self.covariance_matrix_EB = Parameter(name='\Sigma_{EB}', value=None, nonnegative=False) #entanglement-based covariance matrix
        #self.computeCovarianceMatrixEB()
        
        self.beta = Parameter(name='\\beta') #error correction efficiency [adimensional, in [0, 1]]
        self.secret_key_rate = Parameter(name='R', real=True, nonnegative=False) #secret key rate [bit/symbol]
        
        self.I_AB = Parameter(name='I_{AB}')
        self.holevo_information = Parameter(name='I_{AB}')
        
        #Assign expressions to the prepare & measure covariances
        parameter_names = list(vars(self.parameters).keys())
        parameter_names.sort()
        
    def computeCovarianceMatrixPM(self, form='symbolic'):
        """
        This function constructs the prepare & measure covariance matrix.
        
        INPUTS
        ----------
        form : string
            'symbolic' or 'numeric'
        OUTPUTS:
        -------
        CM : 2D array-like of float
            The entanglement-basedprepare & measure (classical) covariance matrix. The modes of the field are ordered as follows:
                1. The classical mode describing the Gaussian-distributed QKD symbols generated by Alice
                2. B_q: mode input to Bob's homodyne detector measuring the q quadrature
                2. B_p: mode input to Bob's homodyne detector measuring the p quadrature
        """
        
        if form=='symbolic':
            CM = vacuum_symbolic(3)
            parameter_names = ["V_s", "n_q", "n_p", "R_B", "eta", "n_c"]
            covariance_names = ['V_q_B', 'V_q_B_nomod', 'V_p_B', 'V_p_B_nomod', 'C_q', 'C_p']
            #Load all the QKD parameter symbols
            V_s, n_q, n_p, R_B, eta, n_c = \
            [getattr(self.parameters, name).symbol for name in parameter_names]
            #Load PM covariance parameters (not symbols)
            V_q_B, V_q_B_nomod, V_p_B, V_p_B_nomod, C_q, C_p =\
                    [getattr(self.covariances_PM, name) for name in covariance_names] 
            if self.channel == "uknown":
                raise InvalidOptionError("The channel should be known for estimating the prepare & measure covariance matrix")     
            else:
                #Construct the covariance matrix
                CM[0, 0] = 2*n_q
                CM[1, 1] = 2*n_p
                CM[0, 1] = CM[1, 0] = 0
                CM[2, 2] = 1/V_s + 2*n_q
                CM[3, 3] = V_s + 2*n_p
                CM[0, 2] = CM[2, 0] = 2*n_q
                CM[1, 3] = CM[3, 1] = 2*n_p
                if self.channel=="thermal-lossy (symmetric)":
                    T_c = vacuum_symbolic(3)
                    T_c[2:4, 2:4] = sympy.sqrt(eta) * vacuum_symbolic(1)
                    N_c = vacuum_symbolic(3)
                    N_c[2:4, 2:4] = (1-eta)*(2*n_c+1)*vacuum_symbolic(1)
                    N_c[0, 0] = N_c[1, 1] = N_c[4, 4] = N_c[5, 5] = 0
                    CM = T_c @ CM @ T_c.T+ N_c
                CM = CM.bs(2, 3, R=R_B)
                CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
                self.covariance_matrix_PM.expression_symbolic = CM
                parameter_names = list(vars(self.parameters).keys())
                parameter_names.sort()
                #Assigna analytical expression to the prepare & measure covariances
                V_q_B.expression_symbolic = CM[2, 2]
                V_q_B_nomod.expression_symbolic = CM[2, 2].subs([(n_q, 0)])
                V_p_B.expression_symbolic = CM[5, 5]
                V_p_B_nomod.expression_symbolic = CM[5, 5].subs([(n_p, 0)])
                C_q.expression_symbolic = CM[0, 2]
                C_p.expression_symbolic = CM[1, 5]
            for covariance_name in covariance_names:
                getattr(self.covariances_PM, covariance_name).expression_numeric = \
                    sympy.lambdify(parameter_names, fromNamesToVariables(str(getattr(self.covariances_PM, covariance_name).expression_symbolic)))
            #Construct a matrix of python functions associated with the expression of the 
            #entries of the covariance matrix
            shape = np.shape(self.covariance_matrix_PM.expression_symbolic)
            CM_numeric = np.empty(shape, dtype=object)
            for j in range(shape[0]):
                for k in range(shape[1]):
                        CM_numeric[j, k] = sympy.lambdify(parameter_names, fromNamesToVariables(str(CM[j, k])))
            self.covariance_matrix_PM.expression_numeric = CM_numeric
        else:
            if self.covariance_matrix_PM.expression_symbolic is None:
                self.computeCovarianceMatrixPM(form='symbolic')
            parameter_values = [p.value for p in self.parameters.toList()]
            shape = np.shape(self.covariance_matrix_PM.expression_symbolic)
            CM = np.zeros(shape)
            for j in range(shape[0]):
                for k in range(shape[1]):
                    CM[j, k] = self.covariance_matrix_PM.expression_numeric[j, k](*parameter_values) 
            self.covariance_matrix_PM.value = CM
            self.covariances_PM.V_q_B.value = CM[2, 2]
            self.covariances_PM.V_p_B.value = CM[5, 5]
            self.covariances_PM.C_q.value = CM[0, 2]
            self.covariances_PM.C_p.value = CM[1, 5]
            #Compute the value of the covariance without modulation
            parameter_values_nomod = parameter_values
            parameter_names = list(vars(self.parameters).keys())
            parameter_names.sort()
            for j in range(len(parameter_names)):
                parameter_name = parameter_names[j]
                if parameter_name in ["n_q", "n_p"]:
                    parameter_values_nomod[j] = 0
            self.covariances_PM.V_q_B_nomod.value = self.covariance_matrix_PM.expression_numeric[2, 2](*parameter_values_nomod)
            self.covariances_PM.V_p_B_nomod.value = self.covariance_matrix_PM.expression_numeric[5, 5](*parameter_values_nomod)

        return CM
    
   
    def computeCovarianceMatrixEB(self, form='symbolic'):
        """
        This function constructs the entanglement-based covariance matrix
        
        INPUTS
        ----------
        form : string
            'symbolic' or 'numeric'
             
        OUTPUTS:
        -------
        CM : 2D array-like of float
            The entanglement-based covariance matrix. The modes of the field are ordered as follows:
                1. A': mode kept by Alice to perform asymmetric homodyne detections on
                2. B: mode input to Bob's asymmetric homodyne detection
        """
              #------------------------------------------
        parameter_names = ["V_s", "n_q", "n_p", "eta", "n_c", "R_B"]
        covariance_names = ['V_q_B', 'V_p_B','C_q', 'C_p']
        if form=='symbolic':
            CM = vacuum_symbolic(2)
            #Load all the QKD parameter symbols
            V_s, n_q, n_p, eta, n_c, R_B = \
            [getattr(self.parameters, name).symbol for name in parameter_names]
            #Load PM covariance parameters (not symbols)
            V_q_B, V_p_B, C_q, C_p =\
                    [getattr(self.covariances_PM, name) for name in covariance_names] 
            #Construct the covariance matrix
            nu = sympy.sqrt((1+2*n_q*V_s)*(V_s+2*n_p)/V_s)
            mu = sympy.sqrt((1+2*n_q*V_s)/(V_s*(V_s+2*n_p)))
            CM = CM.epr_state(1, 2, mu=nu)
            CM = CM.squeeze(0, -sympy.log(mu)/2)
            if self.channel == "thermal-lossy (symmetric)":
                T_c = vacuum_symbolic(2)
                T_c[2:4, 2:4] = sympy.sqrt(eta) * vacuum_symbolic(1)
                N_c = vacuum_symbolic(2)
                N_c[2:4, 2:4] = (1-eta)*(2*n_c+1)*vacuum_symbolic(1)
                N_c[0, 0] = N_c[1, 1] = 0
                CM = T_c @ CM @ T_c.T+ N_c            
            self.covariance_matrix_EB.expression_symbolic = CovarianceMatrix_symbolic(sympy.simplify(CM))
            #Construct a matrix of python functions associated with the expression of the 
            #entries of the covariance matrix
            shape = np.shape(self.covariance_matrix_EB.expression_symbolic)
            CM_numeric = np.empty(shape, dtype=object)
            for j in range(shape[0]):
                for k in range(shape[1]):
                    CM_numeric[j, k] = sympy.lambdify(parameter_names+covariance_names, fromNamesToVariables(str(CM[j, k])))
            self.covariance_matrix_EB.expression_numeric = CM_numeric
        else:
            if self.covariance_matrix_EB.expression_symbolic is None:
                self.computeCovarianceMatrixEB(form='symbolic')
            input_values = []
            for name in parameter_names:
                input_values.append(getattr(self.parameters, name).value)
            for name in covariance_names:
                input_values.append(getattr(self.covariances_PM, name).value)
            shape = np.shape(self.covariance_matrix_EB.expression_symbolic)
            CM = np.zeros(shape)
            for j in range(shape[0]):
                for k in range(shape[0]):
                    CM[j, k] = self.covariance_matrix_EB.expression_numeric[j, k](*input_values)
            self.covariance_matrix_EB.value = CM
        return CM
    

    def computeKeyRate(self, form='symbolic', print_warnings=False):
        """
        This function calculates the secret key rate from the entanglement-based covariance matrix.
        
        INPUTS
        ----------
        print_warnings: boolean
            If 'True', the function will print eventual warnings regarding the calculations. 
        
        OUTPUTS:
        -------
        The value of the secret key rate of the system : float 
        """
        if form=='symbolic':
            attribute = 'symbol'
        else:
            attribute = 'value'
            #Load all the QKD parameters into shorter-named variables
            #Load the needed variances and covariances
        R_B = getattr(self.parameters.R_B, attribute)
        [n_q, n_p] = [getattr(self.parameters.n_q, attribute), getattr(self.parameters.n_p, attribute)]
        V_p_B, C_p = [getattr(self.covariances_PM.V_p_B, attribute), getattr(self.covariances_PM.C_p, attribute)]
        V_q_B, C_q = [getattr(self.covariances_PM.V_q_B, attribute), getattr(self.covariances_PM.C_q, attribute)]
        beta = getattr(self.beta, attribute)
        #Compute the Shannon's mutual information of the modulated (squeezed) signal quadrature measured at the receiver's homodyne detector 'p' 
        #and the modulation signal (QKD symbols) prepared at the transmitter 
       # if form=="numeric":
            #print("I_AB: %0.3f"%I_AB)
        #Compute the entanglement-based covariance matrix of the system
        if form == 'symbolic':     
            CM = self.covariance_matrix_EB.expression_symbolic
            CM_B = vacuum_symbolic(3)
        else:
            CM = self.computeCovarianceMatrixEB(form='numeric')
            CM_B = vacuum(3)
        I_AB = 0
        if form=="numeric":
            if n_p != 0:
                I_AB = QIUtils.mutualInformation(variance_1=CM[1, 1], variance_2=CM[3, 3], covariance=CM[1, 3]) #[bit]
            if n_q != 0:
                I_AB += QIUtils.mutualInformation(variance_1=CM[0, 0], variance_2=CM[2, 2], covariance=CM[0, 2])
        #Compute the entanglement-based covariance matrix after asymmetric homodyne detection of the receiver's mode, along the 'p' quadrature     
        CM_B[0:4, 0:4] = CM
        CM_B = CM_B.pick_modes(1, 3, 2)
        CM_B = CM_B.bs(2, 3, R=R_B)
        if R_B == 0:
            CM_B = CM_B.pick_modes(1, 2)
            CM_B = CM_B.homodyne_detection(2, "p")
        elif R_B == 1:
            CM_B = CM_B.pick_modes(1, 2)
            CM_B = CM_B.homodyne_detection(2, "x")
        else:
            CM_B = CM_B.homodyne_detection(2, "x").homodyne_detection(2, "p")
        
        if print_warnings and CM_B.physicality<0:
            print("\nWarning in keyRate(): the entanglement-based covariance matrix after homodyne detection of the receiver's mode is unphysical.")
        #Compute the von Neumann entropy of the quantum states described by the covariance matrix with and without homodyne detection at the receiver
        S = QIUtils.VonNeumannEntropy(CM, print_warnings=print_warnings) #without homodyne detection
        #print("S: %0.3f"%S)
        S_B = QIUtils.VonNeumannEntropy(CM_B, print_warnings=print_warnings) #with homodyne detection
        #print("S_B: %0.3f"%S_B)
        #Compute the Holevo information
        holevo_information = S - S_B
        #Compute the secret key rate
        R = beta*I_AB - holevo_information
        if form == 'symbolic':
            attribute = 'expression_symbolic'
            R = sympy.simplify(R)
        setattr(self.secret_key_rate, attribute, R)    
        setattr(self.I_AB, attribute, I_AB)
        setattr(self.holevo_information, attribute, holevo_information)
        return R 
    
        
    def estimateParameters(self, parameter_names=None, covariance_names = None, \
                           form='symbolic', configuration='real transmission', minimal=True):
        """
        This function performs parameter estimation of the parameters specified by
        
        Parameters
        ----------
        parameter_names : array-like of string
            The names of the parameters to be estimated, in variables format (e.g., ['eta'])
        covariance_names : array-like of string
            The names of the quadrature covariances from which the parameters are to be estimated, in variable format (e.g., ['V_q_Tx'])
        mode : string
            'symbolc' 'numeric'. The default is 'symbolic'.
        configuration : string
        
            -'back-to-back': estimation of the QKD parameters without quantum channel
            
            -'real transmission': estimation of the QKD parameters with a quantum channel 
            
            The default is 'real transmission'.
        
        minimal : boolean
            If True, then parameter estimation is performed by considering the simplified
            expressions for the prepare & measure covariances, where the trusted losses are
            grouped into T_Tx, T_A, T_p and T_q.

        Returns
        -------
        None.

        """

        #Load the target parameters
        if parameter_names is None:
            raise ParameterEstimationError('No parameters were specified.')  
        equations_specified = covariance_names is not None
        #Load the prepare & measure covariances as parameters
        parameter_names.sort()
        covariance_names.sort()
        parameters = [getattr(self.parameters, name) for name in parameter_names]
        #Load the known parameteres
        known_parameter_names = [name for name in list(vars(self.parameters).keys()) if name not in parameter_names+['eta', 'w_q', 'w_p']]
        known_parameter_names.sort()
        known_parameters = [getattr(self.parameters, name) for name in known_parameter_names]
        analytical_expression_missing = sum([p.expression_symbolic is None for p in parameters]) > 0
        #Check for possible errors in the input
        if not(equations_specified) and analytical_expression_missing:
            raise ParameterEstimationError("Analytical expressions of the parameters to be estimated are not available, but prepare & measure covariances were not specified."\
                                           +"\n You need to specify the covariances which parameters are estimated from.")
        if minimal:
            covariances= [getattr(self.covariances_PM_simplified, name) for name in covariance_names]
        else:     
            covariances= [getattr(self.covariances_PM, name) for name in covariance_names]
        #Symbolic parameter estimation 
        if form=='symbolic':
            #Set up the system of equations for estimating parameters
            system = []
            for covariance in covariances:
                if configuration=='back-to-back':
                    system.append(sympy.Eq(covariance.expression_symbolic.subs([(self.parameters.eta.symbol, 1)]), covariance.symbol))
                else:
                    system.append(sympy.Eq(covariance.expression_symbolic, covariance.symbol))
            system = tuple(system)
            parameter_symbols = [p.symbol for p in parameters]
            #Solve the system of equations
            try:
                solutions = sympy.solve(system, tuple(parameter_symbols), dict=True)[0]
            except:
                raise ParameterEstimationError('No solution was found')
            #Set the symbolic expressions into the QKD system
            for solution_symbol in list(solutions.keys()):
                parameter = [p for p in parameters if p.name==solution_symbol.name][0]
                parameter.expression_symbolic = solutions[solution_symbol]
                parameter.expression_numeric = sympy.lambdify(known_parameter_names+covariance_names, fromNamesToVariables(str(solutions[solution_symbol])))  
        else: 
            if analytical_expression_missing:
                self.estimateParameters(parameter_names=parameter_names, covariance_names=covariance_names, form='symbolic', configuration=configuration)
            #Load the known parameters as symbols or values
            known_parameters = [p.value for p in known_parameters]
            #Load the prepare & measure covariances as symbols or values
            covariances = [c.value for c in covariances]
            for parameter in parameters:
                parameter.value = parameter.expression_numeric(*(known_parameters+covariances))
                        
#%%    
def fromNamesToVariables(string_symbols):
    """
    This function converts a string containing a symbolic expression
    into a string corresponding to the same Python expression with names of variables. 
    """
    return string_symbols.replace('(nomod)', '_nomod').replace('{', '').replace('}', '').replace('\\eta', 'eta')
#%%
#Define exceptions
class ParameterEstimationError(Exception):
    def __init__(self, error_message):
        print(error_message)
        
class InvalidOptionError(Exception):
    def __init__(self, error_message='The selected option is invalid'):
        print(error_message)
        