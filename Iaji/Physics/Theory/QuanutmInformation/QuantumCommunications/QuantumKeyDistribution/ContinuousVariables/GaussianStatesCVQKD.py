"""
This file defines classes that describe a fully-Gaussian CVQKD system, where
the p quadrature is squeezed, both p and q are modulated according to a Gaussian distribution
and the receiver performs a generally asymmetric and simultaneous homodyne detection of
q and p. 
"""

#%%
#Imports
import numpy as np
import sympy
sympy.init_printing()
from Iaji.Physics.Theory.QuanutmInformation import QuantumInformationUtilities as QIUtils
from quik.qip.nmodes import vacuum
from quik.qip.nmodes_symbolic import Vacuum as vacuum_symbolic
from quik.qip.nmodes_symbolic import CovarianceMatrix as CovarianceMatrix_symbolic
#%%
class Parameter:
    """
    This class describes a generic parameter. A parameter is described by the following properties:
        -name
        
        -symbol
        
        -value: the numerical value of the parameter
        
        -expression_symbolic: a symbolic mathematical expression of the parameter, in terms of other symbols
       
        -expression_numeric: a function that allows numerical evaluation of the parameter's value form numerical input parameters
    """
    
    def __init__(self, name='x', value=None, real=True, nonnegative=True):
        self.name = name
        self.value = value
        self.symbol = sympy.symbols(names=name, real=real, nonnegative=nonnegative)
        self.expression_symbolic = None
        self.expression_numeric = None
#%%
class QKDParameters:
    """
    This class describes the parameters of the QKD system:
        
    - n_q, n_p: real, > 0.

         mean photon number of the thermal state generated by Gaussian modulation of a displaced vacuum state along quadratures q and p, at the input of the channel.
         
    - V_s$ real, > 0.

        variance of the squeezed quadrature of the unmodulated signal, at the input of the channel.

    - n_c: real, > 0

        mean photon number of the excess thermal noise, at the input of a thermal-lossy channel 
        
    - T_A: real, [0, 1]
        
        Power transmission efficiency of the transmitter
    
    - \eta: real, [0, 1]

        power transmission efficiency of the quantum channel.

    - T_{B}: real, [0, 1]

        power transmission efficiency of the receiver, besides the measurement beam splitter
    
    - R_{A} : real,  [0, 1]
    
        power reflectivity of the transmitter's beam splitter in the entanglement-based protocol
    
    - R_{B}: real, [0, 1]

        power reflectivity of the receiver's beam splitter.
        
    - \sigma_{\phi_{A}}: real, > 0
        standard deviation of the Gaussian phase noise from the transmitter's local oscillaltor
        
    - \sigma_{\phi_{B}}: real, > 0
        standard deviation of the Gaussian phase noise from the receiver's local oscillaltor
    """      
    
    def __init__(self, T_A=None, eta=None, R_B=None, V_s=None, \
                 n_q=None, n_p=None, n_c=None, sigma_phi_A=None, sigma_phi_B=None):
        self.T_A = Parameter(name='T_A', value=T_A)
        self.eta = Parameter(name='\\eta', value=eta)
        self.R_B = Parameter(name='R_B', value=R_B)
        self.V_s = Parameter(name='V_s', value=V_s)     
        self.n_q = Parameter(name='n_q', value=n_q)
        self.n_p = Parameter(name='n_p', value=n_p)
        self.n_c = Parameter(name='n_c', value=n_c)
        self.sigma_phi_A = Parameter(name='\\sigma_{\\phi_A}', value=sigma_phi_A)
        self.sigma_phi_B = Parameter(name='\\sigma_{\\phi_B}', value=sigma_phi_B) 
        #Define auxiliary parameters used for minimal complete parameter estimation
        #Transmission efficiency from the output of the channel to the input of homodyne detector Rx-q
    def toList(self):
        """
        This function returns a list of all the QKD parameters, ordered by their name
        """
        dictionary = vars(self)
        dictionary_sorted = dict(sorted(dictionary.items(), key=lambda item: item[0]))
        return list(dictionary_sorted.values())  
    
    def toDict(self, attribute='name'):
        """
        This function returns a dictionary of all the QKD parameters, with keys given
        by the parameter attribute 'attribute'.
        
        INPUTS
        ------------------
        attribute : string
            The attribute used as key to the dictionary. Refer to Parameter class for the attributes.
        """
        
        parameters = self.toList() 
        attributes = [getattr(p, attribute) for p in parameters]
        return dict(zip(attributes, parameters))
        

#%%
class QKDPrepareAndMeasureCovariances:
    """
    This class defines the entries of the prepare & measure covariance
    matrix of the QKD system, relevant to experimental parameter estimation:
        
        - V_{q_A}: variance of the q quadrature detected at homodomdyne detector Tx

        - V_{q_B}: variance of the q quadrature detected at homodomdyne detector Rx-q

        - V_{p_B}: variance of the p quadrature detected at homodomdyne detector Rx-p

        - V_{p_B(nomod)}: variance of the p quadrature detected at homodomdyne detector Rx-p without modulation ($n_q=0$)

        - V_{q_B(nomod)}: variance of the q quadrature detected at homodomdyne detector Rx-q without modulation ($n_p=0$)

        - C_p: covariance between the p quadrature detected at homodyne detector Rx-p and the corresponding generated QKD symbols

        - C_q: covariance between the q quadrature detected at homodyne detector Rx-q and the corresponding generated QKD symbols
    """

    def __init__(self, V_q_A=None, V_q_B=None, V_p_B=None, V_p_B_nomod=None, V_q_B_nomod=None, C_p=None, C_q=None):
        self.V_q_B = Parameter(name='V_{q_B}', value=V_q_B)
        self.V_p_B = Parameter(name='V_{p_B}', value=V_p_B)
        self.V_p_B_nomod = Parameter(name='V_{p_B(nomod)}', value=V_p_B_nomod)
        self.V_q_nomod_Rx_q = Parameter(name='B_{q_B(nomod)}', value=V_q_B_nomod)
        self.C_q = Parameter(name='C_q', value=C_q)
        self.C_p = Parameter(name='C_p', value=C_p)
        
    def toList(self):
        """
        This function returns a list of all the QKD parameters, ordered by their name
        """
        dictionary = vars(self)
        dictionary_sorted = dict(sorted(dictionary.items(), key=lambda item: item[0]))
        return list(dictionary_sorted.values())     
    
#%%+
class QKDSystem:
    """
    This class describes a QKD system, which has the following properties:
        - A set of QKD parameters
        - A prepare & measure covariance matrix (quantum mechanical and classical)
        - An entanglement-based covariance matrix
        - An error correction efficiency
        - A set of experimentally measured covariances, i.e., entries of the prepare & measure classical covariance matrix
        - A secret key rate
    
    The class allows to perform the following tasks:
        - Compute the covariance matrices associated to the system, given QKD parameters (symbolically and numerically)
        - Perform parameter estimation (symbolically and numerically)
        - Estimate the secret key rate (numerically)
        
    The vacuum quadrature variance is assumed to be equal to 1. All quadrature covariances are 
    normalized to the vacuum quadrature variance.
    """    
    
    def __init__(self, parameters=QKDParameters(), covariances_PM=QKDPrepareAndMeasureCovariances(), \
                 error_correction_efficiency=1):
        self.parameters = parameters #QKD parameters
        self.covariances_PM = covariances_PM #prepare and measure covariances
        
        self.covariance_matrix_EB = Parameter(name='\Sigma_{EB}', value=None, nonnegative=False) #entanglement-based covariance matrix
        self.computeCovarianceMatrixEB()
        
        self.beta = Parameter(name='\\beta') #error correction efficiency [adimensional, in [0, 1]]
        self.secret_key_rate = Parameter(name='R', real=True, nonnegative=False) #secret key rate [bit/symbol]
        
        #Assign expressions to the prepare & measure covariances
        parameter_names = list(vars(self.parameters).keys())
        parameter_names.sort()
   
    def computeCovarianceMatrixEB(self, form='symbolic', print_warnings=False):
        """
        This function constructs the entanglement-based covariance matrix
        
        INPUTS
        ----------
        mode : string
            'symbolic' or 'numeric'
        print_warnings : boolean
            If True, sanity check warnings on the covariance matrix are printed 
            after the calculation.
             
        OUTPUTS:
        -------
        CM : 2D array-like of float
            The entanglement-based covariance matrix. The modes of the field are ordered as follows:
                1. A': mode kept by Alice to perform asymmetric homodyne detections on
                2. B: mode input to Bob's asymmetric homodyne detection
        """
              #------------------------------------------
        if form=='symbolic':
            CM = vacuum_symbolic(2)
             #Load all the QKD parameters into shorter-named variables
            V_s, n_q, n_p, R_B, V_q_B, V_p_B, C_q, C_p = \
            [self.parameters.V_s.symbol, self.parameters.n_q.symbol, self.parameters.n_p.symbol, \
             self.parameters.R_B.symbol, self.covariances_PM.V_q_B.symbol, self.covariances_PM.V_p_B.symbol, \
             self.covariances_PM.C_q.symbol, self.covariances_PM.C_p.symbol]
            #Construct the covariance matrix
            CM[0, 0] = 1/V_s+2*n_q
            CM[1, 1] = V_s+2*n_p
            CM[2, 2] = (V_q_B-1)/R_B+1
            CM[3, 3] = (V_p_B-1)/(1-R_B)+1
            CM[0, 2] = CM[2, 0] = C_q/(sympy.sqrt(R_B))
            CM[1, 3] = CM[3, 1] = C_p/(sympy.sqrt(1-R_B))
            self.covariance_matrix_EB.expression_symbolic = CovarianceMatrix_symbolic(CM)
            #Construct a matrix of python functions associated with the expression of the 
            #entries of the covariance matrix
            parameter_names = list(vars(self.parameters).keys())
            parameter_names.sort()
            CM_numeric = np.empty((3, 3), dtype=object)
            for j in range(3):
                for k in range(3):
                        CM_numeric[j, k] = sympy.lambdify(parameter_names, fromNamesToVariables(str(CM[j, k])))
            self.covariance_matrix_EB.expression_numeric = CM_numeric
        else:
            if self.covariance_matrix_EB.expression_symbolic is None:
                self.computeCovarianceMatrixEB(form='symbolic')
            parameter_values = [p.value for p in self.parameters.toList()]
            CM = np.zeros((3, 3))
            for j in range(3):
                for k in range(3):
                    CM[j, k] = self.covariance_matrix_EB.expression_numeric(*parameter_values)
        return CM
    

    def keyRate(self, form='symbolic', print_warnings=False):
        """
        This function calculates the secret key rate from the entanglement-based covariance matrix.
        
        INPUTS
        ----------
        print_warnings: boolean
            If 'True', the function will print eventual warnings regarding the calculations. 
        
        OUTPUTS:
        -------
        The value of the secret key rate of the system : float 
        """
        if form=='symbolic':
            #Load all the QKD parameters into shorter-named variables
            #Load the needed variances and covariances
            R_B = self.parameters.R_B.symbol
            [n_q, n_p] = [self.parameters.n_q.symbol, self.parameters.n_p.symbol]
            V_p_B, C_p = [self.covariances_PM.V_p_B.symbol, self.covariances_PM.C_p.symbol]
            V_q_B, C_q = [self.covariances_PM.V_q_B.symbol, self.covariances_PM.C_q.symbol]
            beta = self.beta.symbol
            #Compute the Shannon's mutual information of the modulated (squeezed) signal quadrature measured at the receiver's homodyne detector 'p' 
            #and the modulation signal (QKD symbols) prepared at the transmitter 
            I_AB = QIUtils.mutualInformation(variance_1=V_p_B, variance_2=2*n_p, covariance=C_p) #[bit]
            I_AB += QIUtils.mutualInformation(variance_1=V_q_B, variance_2=2*n_q, covariance=C_q)
            #Compute the entanglement-based covariance matrix of the system
            CM = self.covariance_matrix_EB.expression_symbolic
            #Compute the entanglement-based covariance matrix after asymmetric homodyne detection of the receiver's mode, along the 'p' quadrature
            CM_B = vacuum_symbolic(3)
            CM_B[0:4, 0:4] = CM
            CM_B = CM_B.pick_modes(1, 3, 2)
            CM_B = CM_B.bs(2, 3, R=R_B)
            CM_B = CM_B.homodyne_detection(2, 'p').homodyne_detection(2, 'x')
            if print_warnings and CM_B.physicality<0:
                print("\nWarning in keyRate(): the entanglement-based covariance matrix after homodyne detection of the receiver's mode is unphysical.")
            #Compute the von Neumann entropy of the quantum states described by the covariance matrix with and without homodyne detection at the receiver
            S = QIUtils.VonNeumannEntropy(CM, print_warnings=print_warnings) #without homodyne detection
            S_B = QIUtils.VonNeumannEntropy(CM_B, print_warnings=print_warnings) #with homodyne detection
            #Compute the Holevo information
            holevo_information = S - S_B
            
            #Compute the secret key rate
            R = beta*I_AB - holevo_information
            R = sympy.simplify(R)
            self.secret_key_rate.expression_symbolic = R 
        return R 
    

        
    def estimateParameters(self, parameter_names=None, covariance_names = None, \
                           form='symbolic', configuration='real transmission', minimal=True):
        """
        This function performs parameter estimation of the parameters specified by
        
        Parameters
        ----------
        parameter_names : array-like of string
            The names of the parameters to be estimated, in variables format (e.g., ['eta'])
        covariance_names : array-like of string
            The names of the quadrature covariances from which the parameters are to be estimated, in variable format (e.g., ['V_q_Tx'])
        mode : string
            'symbolc' 'numeric'. The default is 'symbolic'.
        configuration : string
        
            -'back-to-back': estimation of the QKD parameters without quantum channel
            
            -'real transmission': estimation of the QKD parameters with a quantum channel 
            
            The default is 'real transmission'.
        
        minimal : boolean
            If True, then parameter estimation is performed by considering the simplified
            expressions for the prepare & measure covariances, where the trusted losses are
            grouped into T_Tx, T_A, T_p and T_q.

        Returns
        -------
        None.

        """

        #Load the target parameters
        if parameter_names is None:
            raise ParameterEstimationError('No parameters were specified.')  
        equations_specified = covariance_names is not None
        #Load the prepare & measure covariances as parameters
        parameter_names.sort()
        covariance_names.sort()
        parameters = [getattr(self.parameters, name) for name in parameter_names]
        #Load the known parameteres
        known_parameter_names = [name for name in list(vars(self.parameters).keys()) if name not in parameter_names+['eta', 'w_q', 'w_p']]
        known_parameter_names.sort()
        known_parameters = [getattr(self.parameters, name) for name in known_parameter_names]
        analytical_expression_missing = sum([p.expression_symbolic is None for p in parameters]) > 0
        #Check for possible errors in the input
        if not(equations_specified) and analytical_expression_missing:
            raise ParameterEstimationError("Analytical expressions of the parameters to be estimated are not available, but prepare & measure covariances were not specified."\
                                           +"\n You need to specify the covariances which parameters are estimated from.")
        if minimal:
            covariances= [getattr(self.covariances_PM_simplified, name) for name in covariance_names]
        else:     
            covariances= [getattr(self.covariances_PM, name) for name in covariance_names]
        #Symbolic parameter estimation 
        if form=='symbolic':
            #Set up the system of equations for estimating parameters
            system = []
            for covariance in covariances:
                if configuration=='back-to-back':
                    system.append(sympy.Eq(covariance.expression_symbolic.subs([(self.parameters.eta.symbol, 1)]), covariance.symbol))
                else:
                    system.append(sympy.Eq(covariance.expression_symbolic, covariance.symbol))
            system = tuple(system)
            parameter_symbols = [p.symbol for p in parameters]
            #Solve the system of equations
            try:
                solutions = sympy.solve(system, tuple(parameter_symbols), dict=True)[0]
            except:
                raise ParameterEstimationError('No solution was found')
            #Set the symbolic expressions into the QKD system
            for solution_symbol in list(solutions.keys()):
                parameter = [p for p in parameters if p.name==solution_symbol.name][0]
                parameter.expression_symbolic = solutions[solution_symbol]
                parameter.expression_numeric = sympy.lambdify(known_parameter_names+covariance_names, fromNamesToVariables(str(solutions[solution_symbol])))  
        else: 
            if analytical_expression_missing:
                self.estimateParameters(parameter_names=parameter_names, covariance_names=covariance_names, form='symbolic', configuration=configuration)
            #Load the known parameters as symbols or values
            known_parameters = [p.value for p in known_parameters]
            #Load the prepare & measure covariances as symbols or values
            covariances = [c.value for c in covariances]
            for parameter in parameters:
                parameter.value = parameter.expression_numeric(*(known_parameters+covariances))
                        
#%%    
def fromNamesToVariables(string_symbols):
    """
    This function converts a string containing a symbolic expression
    into a string corresponding to the same Python expression with names of variables. 
    """
    return string_symbols.replace('^{(', '_').replace(')}', '').replace('Tx/', 'Tx_')\
            .replace('mod/', 'mod_')\
            .replace('{', '').replace('}', '').replace('Rx-', 'Rx_').replace('\\', '')\
            .replace('Tx_q', 'q_Tx').replace('Rx_q_q', 'q_Rx_q').replace('Rx_p_q', 'q_Rx_p')\
            .replace('Rx_p_p', 'p_Rx_p').replace('Rx_p(nomod', 'nomod_Rx_p').replace('Rx_q(nomod', 'nomod_Rx_q')\
            .replace('mod_p', 'p_mod') .replace('mod_q', 'q_mod')  
#%%
#Define exceptions
class ParameterEstimationError(Exception):
    def __init__(self, error_message):
        print(error_message)
        