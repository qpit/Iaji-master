"""
This file defines classes that describe a QKD system, specifically 
a QKD system based on the Gaussian modulation of the squeezed and antisqueezed quadrature of one mode of a bosonic field.
"""

#%%
#Imports
import numpy as np
import sympy
sympy.init_printing()
from Iaji.Physics.Theory.QuanutmInformation import QuantumInformationUtilities as QIUtils
from quik.qip.nmodes import vacuum
from quik.qip.nmodes_symbolic import Vacuum as vacuum_symbolic
from quik.qip.nmodes_symbolic import CovarianceMatrix as CovarianceMatrix_symbolic
#%%
class Parameter:
    """
    This class describes a generic parameter. A parameter is described by the following properties:
        -name
        
        -symbol
        
        -value: the numerical value of the parameter
        
        -expression_symbolic: a symbolic mathematical expression of the parameter, in terms of other symbols
       
        -expression_numeric: a function that allows numerical evaluation of the parameter's value form numerical input parameters
    """
    
    def __init__(self, name='x', value=None, real=True, nonnegative=True):
        self.name = name
        self.value = value
        self.symbol = sympy.symbols(names=name, real=real, nonnegative=nonnegative)
        self.expression_symbolic = None
        self.expression_numeric = None
#%%
class QKDParameters:
    """
    This class describes the parameters of the QKD system:
        
    - n_q, n_p: real, > 0.

         mean photon number of the thermal state generated by Gaussian modulation of a displaced vacuum state along quadratures q and p, at the input of the channel.
         
    - V_s$ real, > 0.

        variance of the squeezed quadrature of the unmodulated signal, at the input of the channel.

    - V_a: real, > 0.

        variance of the antisqueezed quadrature of the unmodulated signal, at the input of the channel.

    - w_q, w_p: real, > 0

        mean photon number of the excess thermal noise in the state prepared by the eavesdropper, at the channel input
        
    - T_Tx: real, [0, 1]
        
        Power transmission efficiency from the output of the displacement beam splitter to the input of the channel
    
    - \eta: real, [0, 1]

        power transmission efficiency of the quantum channel.

    - \tau_{Rx}: real, [0, 1]

        power transmission efficiency from the channel's output to the receiver's beam splitter input.

    - \tau_q, \tau_p: real, [0, 1]

        power transmission efficiency from the output of the receiver's beam splitter to the input of the receiver's homodyne detector, measuring q, p.

    - t_q, t_p: real, > 0

        mean photon number corresponding to the thermal noise added by homodyne detectors Rx-q and Rx-p
    
    - R_{Rx}: real, [0, 1]

        power reflectivity of the receiver's beam splitter.
        
    - \sigma_{\phi_{Tx}}: real, > 0
        standard deviation of the Gaussian phase noise from the transmitter's local oscillaltor
        
    - \sigma_{\phi_{Rx}}: real, > 0
        standard deviation of the Gaussian phase noise from the receiver's local oscillaltor
    
    - T_q: real, [0, 1]
        Auxiliary parameter, equal to \tau_{Rx}*R_{Rx}*tau_q
    
    - T_p: real, [0, 1]
        Auxiliary parameter, equal to \tau_{Rx}*(1-R_{Rx})*tau_p
    """      
    
    def __init__(self, T_Tx=None, eta=None, tau_Rx=None,  R_Rx=None, tau_q=None, t_q=None, tau_p=None,\
                 t_p=None, V_s=None, V_a=None, n_q=None, n_p=None, w_q=None, w_p=None, sigma_phi_Tx=None, sigma_phi_Rx=None):
        self.T_Tx = Parameter(name='T_{Tx}', value=T_Tx)
        self.eta = Parameter(name='\\eta', value=eta)
        self.tau_Rx = Parameter(name='\\tau_{Rx}', value=tau_Rx)
        self.R_Rx = Parameter(name='R_{Rx}', value=R_Rx)
        self.tau_q = Parameter(name='\\tau_q', value=tau_q)
        self.t_q = Parameter(name='t_q', value=t_q)
        self.tau_p = Parameter(name='\\tau_p', value=tau_q)
        self.t_p = Parameter(name='t_p', value=t_p)
        self.V_s = Parameter(name='V_s', value=V_s)
        self.V_a = Parameter(name='V_a', value=V_a)
        self.n_q = Parameter(name='n_q', value=n_q)
        self.n_p = Parameter(name='n_p', value=n_p)
        self.w_q = Parameter(name='w_q', value=w_q)
        self.w_p = Parameter(name='w_p', value=w_p)
        self.sigma_phi_Tx = Parameter(name='\\sigma_{\\phi_{Tx}}', value=sigma_phi_Tx)
        self.sigma_phi_Rx = Parameter(name='\\sigma_{\\phi_{Rx}}', value=sigma_phi_Rx) 
        #Define auxiliary parameters used for minimal complete parameter estimation
        #Transmission efficiency from the output of the channel to the input of homodyne detector Rx-q
        if R_Rx is None or tau_Rx is None:
            value = None
        else:
            value = tau_Rx*R_Rx*tau_q
        self.T_q = Parameter(name='T_q', value=value)
        #self.T_q.expression_symbolic = self.tau_Rx.symbol*self.R_Rx.symbol*self.tau_q.symbol   
        #Transmission efficiency from the output of the channel to the input of homodyne detector Rx-p
        if R_Rx is None or tau_Rx is None:
            value = None
        else:
            value = tau_Rx*(1-R_Rx)*tau_p
        self.T_p = Parameter(name='T_p', value=value)
        #self.T_p.expression_symbolic = self.tau_Rx.symbol*(1-self.R_Rx.symbol)*self.tau_p.symbol
        
    def toList(self):
        """
        This function returns a list of all the QKD parameters, ordered by their name
        """
        dictionary = vars(self)
        dictionary_sorted = dict(sorted(dictionary.items(), key=lambda item: item[0]))
        return list(dictionary_sorted.values())  
    
    def toDict(self, attribute='name'):
        """
        This function returns a dictionary of all the QKD parameters, with keys given
        by the parameter attribute 'attribute'.
        
        INPUTS
        ------------------
        attribute : string
            The attribute used as key to the dictionary. Refer to Parameter class for the attributes.
        """
        
        parameters = self.toList() 
        attributes = [getattr(p, attribute) for p in parameters]
        return dict(zip(attributes, parameters))
        

#%%
class QKDPrepareAndMeasureCovariances:
    """
    This class defines the entries of the prepare & measure covariance
    matrix of the QKD system, relevant to experimental parameter estimation:
        
        - V^{(Tx)}_q: variance of the q quadrature detected at homodomdyne detector Tx

        - V^{(Rx-q)}_q: variance of the q quadrature detected at homodomdyne detector Rx-q

        - V^{(Rx-p)}_q: variance of the q quadrature detected at homodomdyne detector Rx-p

        - V^{(Rx-p)}_p: variance of the p quadrature detected at homodomdyne detector Rx-p

        - V^{(Rx-p)}_{p(nomod)}: variance of the p quadrature detected at homodomdyne detector Rx-p without modulation ($n_q=0$)

        - V^{(Rx-q)}_{q(nomod)}: variance of the q quadrature detected at homodomdyne detector Rx-q without modulation ($n_p=0$)

        - C^{(mod/Rx-p)}_p: covariance between the p quadrature detected at homodyne detector Rx-p and the corresponding generated QKD symbols

        - C^{(mod/Rx-q)}_q: covariance between the q quadrature detected at homodyne detector Rx-q and the corresponding generated QKD symbols

    """

    def __init__(self, V_q_Rx_q=None, V_q_Rx_p=None, V_p_Rx_p=None,\
                 V_p_nomod_Rx_p=None, V_q_nomod_Rx_q=None,C_p_mod_Rx_p=None, C_q_mod_Rx_q=None):
        self.V_q_Rx_q = Parameter(name='V^{(Rx-q)}_q', value=V_q_Rx_q)
        self.V_q_Rx_p = Parameter(name='V^{(Rx-p)}_q', value=V_q_Rx_p)
        self.V_p_Rx_p = Parameter(name='V^{(Rx-p)}_p', value=V_p_Rx_p)
        self.V_p_nomod_Rx_p = Parameter(name='V^{(Rx-p)}_{p(nomod)}', value=V_p_nomod_Rx_p)
        self.V_q_nomod_Rx_q = Parameter(name='V^{(Rx-q)}_{q(nomod)}', value=V_q_nomod_Rx_q)
        self.C_q_mod_Rx_q = Parameter(name='C^{(mod/Rx-q)}_q', value=C_q_mod_Rx_q)
        self.C_p_mod_Rx_p = Parameter(name='C^{(mod/Rx-p)}_p', value=C_p_mod_Rx_p)
        
    def toList(self):
        """
        This function returns a list of all the QKD parameters, ordered by their name
        """
        dictionary = vars(self)
        dictionary_sorted = dict(sorted(dictionary.items(), key=lambda item: item[0]))
        return list(dictionary_sorted.values())     
    
#%%+
class QKDSystem:
    """
    This class describes a QKD system, which has the following properties:
        - A set of QKD parameters
        - A prepare & measure covariance matrix (quantum mechanical and classical)
        - An entanglement-based covariance matrix
        - An error correction efficiency
        - A set of experimentally measured covariances, i.e., entries of the prepare & measure classical covariance matrix
        - A secret key rate
    
    The class allows to perform the following tasks:
        - Compute the covariance matrices associated to the system, given QKD parameters (symbolically and numerically)
        - Perform parameter estimation (symbolically and numerically)
        - Estimate the secret key rate (numerically)
        
    The vacuum quadrature variance is assumed to be equal to 1. All quadrature covariances are 
    normalized to the vacuum quadrature variance.
    """    
    
    def __init__(self, parameters=QKDParameters(), covariances_PM=QKDPrepareAndMeasureCovariances(), \
                 error_correction_efficiency=1):
        self.parameters = parameters #QKD parameters
        self.covariances_PM = covariances_PM #prepare and measure covariances
        
        self.covariance_matrix_PM = Parameter(name='\Sigma_{PM}', value=None, nonnegative=False) #prepare & measure covariance matrix
        self.computeCovarianceMatrixPM()
        
        self.covariance_matrix_PM_classical = Parameter(name='\Sigma_{PM(classical)}', value=None, nonnegative=False) #prepare & measure classical covariance matrix
        self.computeCovarianceMatrixPMClassical()
        
        self.covariance_matrix_EB = Parameter(name='\Sigma_{EB}', value=None, nonnegative=False) #entanglement-based covariance matrix
        self.computeCovarianceMatrixEB()
        
        self.beta = Parameter(name='\\beta') #error correction efficiency [adimensional, in [0, 1]]
        self.secret_key_rate = Parameter(name='R', real=True, nonnegative=False) #secret key rate [bit/symbol]
        
        #Assign expressions to the prepare & measure covariances
        parameter_names = list(vars(self.parameters).keys())
        parameter_names.sort()
        
        
        self.covariances_PM.V_q_Rx_q.expression_symbolic = self.covariance_matrix_PM_classical.expression_symbolic[0, 0]
        self.covariances_PM.V_q_Rx_q.expression_numeric = sympy.lambdify(parameter_names, fromNamesToVariables(str(self.covariances_PM.V_q_Rx_q.expression_symbolic)))
    
        self.covariances_PM.V_q_Rx_p.expression_symbolic = self.covariance_matrix_PM_classical.expression_symbolic[2, 2]
        self.covariances_PM.V_q_Rx_p.expression_numeric = sympy.lambdify(parameter_names, fromNamesToVariables(str(self.covariances_PM.V_q_Rx_p.expression_symbolic)))
    
        self.covariances_PM.V_p_Rx_p.expression_symbolic = self.covariance_matrix_PM_classical.expression_symbolic[3, 3]
        self.covariances_PM.V_p_Rx_p.expression_numeric = sympy.lambdify(parameter_names, fromNamesToVariables(str(self.covariances_PM.V_p_Rx_p.expression_symbolic)))
        
        self.covariances_PM.V_q_nomod_Rx_q.expression_symbolic = self.covariance_matrix_PM_classical.expression_symbolic[3, 3].subs([(self.parameters.n_q.symbol, 0)])
        self.covariances_PM.V_q_nomod_Rx_q.expression_numeric = sympy.lambdify(parameter_names, fromNamesToVariables(str(self.covariances_PM.V_q_nomod_Rx_q.expression_symbolic)))

        self.covariances_PM.V_p_nomod_Rx_p.expression_symbolic = self.covariance_matrix_PM_classical.expression_symbolic[3, 3].subs([(self.parameters.n_p.symbol, 0)])
        self.covariances_PM.V_p_nomod_Rx_p.expression_numeric = sympy.lambdify(parameter_names, fromNamesToVariables(str(self.covariances_PM.V_p_nomod_Rx_p.expression_symbolic)))

        self.covariances_PM.C_q_mod_Rx_q.expression_symbolic = self.covariance_matrix_PM_classical.expression_symbolic[3, 5]
        self.covariances_PM.C_q_mod_Rx_q.expression_numeric = sympy.lambdify(parameter_names, fromNamesToVariables(str(self.covariances_PM.C_q_mod_Rx_q.expression_symbolic)))

        self.covariances_PM.C_p_mod_Rx_p.expression_symbolic = self.covariance_matrix_PM_classical.expression_symbolic[2, 4]
        self.covariances_PM.C_p_mod_Rx_p.expression_numeric = sympy.lambdify(parameter_names, fromNamesToVariables(str(self.covariances_PM.C_p_mod_Rx_p.expression_symbolic)))
        
        #Construct a set of simplified prepare & measure covariances, derived by hand
        self.covariances_PM_simplified = QKDPrepareAndMeasureCovariances()
        #Assign symbolic and numeric expressions
        T_Tx = self.parameters.T_Tx.symbol
        eta = self.parameters.eta.symbol
        T_q = self.parameters.T_q.symbol
        T_p = self.parameters.T_p.symbol
        t_q = self.parameters.t_q.symbol
        t_p = self.parameters.t_p.symbol
        V_a = self.parameters.V_a.symbol
        V_s = self.parameters.V_s.symbol
        n_q = self.parameters.n_q.symbol
        n_p = self.parameters.n_p.symbol
        w_q = self.parameters.w_q.symbol
        w_p = self.parameters.w_p.symbol
        
        input_parameter_names = ['T_Tx', 'eta', 'T_q', 'T_p', 't_q', 't_p', 'V_a', 'V_s', 'n_q', 'n_p', 'w_q', 'w_p']
        input_parameter_names.sort()
        
        
        self.covariances_PM_simplified.V_q_Rx_q.expression_symbolic = 2*w_q*T_q*(1-eta)+eta*T_q*(V_a+2*n_q-1) + 2*t_q + 1
        self.covariances_PM_simplified.V_q_Rx_q.expression_numeric = sympy.lambdify(input_parameter_names, fromNamesToVariables(str(self.covariances_PM_simplified.V_q_Rx_q.expression_symbolic)))
        
        self.covariances_PM_simplified.V_q_Rx_p.expression_symbolic = 2*w_q*T_p*(1-eta)+eta*T_p*(V_a+2*n_q-1) + 2*t_p + 1
        self.covariances_PM_simplified.V_q_Rx_p.expression_numeric = sympy.lambdify(input_parameter_names, fromNamesToVariables(str(self.covariances_PM_simplified.V_q_Rx_p.expression_symbolic)))
  
        self.covariances_PM_simplified.V_p_Rx_p.expression_symbolic = 2*w_p*T_p*(1-eta)+eta*T_p*(V_s+2*n_p-1) + 2*t_p + 1
        self.covariances_PM_simplified.V_p_Rx_p.expression_numeric = sympy.lambdify(input_parameter_names, fromNamesToVariables(str(self.covariances_PM_simplified.V_p_Rx_p.expression_symbolic)))

        self.covariances_PM_simplified.V_q_nomod_Rx_q.expression_symbolic = 2*w_q*T_q*(1-eta)+eta*T_q*(V_a-1) + 2*t_q + 1
        self.covariances_PM_simplified.V_q_nomod_Rx_q.expression_numeric = sympy.lambdify(input_parameter_names, fromNamesToVariables(str(self.covariances_PM_simplified.V_q_nomod_Rx_q.expression_symbolic)))
    
        self.covariances_PM_simplified.V_p_nomod_Rx_p.expression_symbolic = 2*w_p*T_p*(1-eta)+eta*T_p*(V_s-1) + 2* t_p + 1
        self.covariances_PM_simplified.V_p_nomod_Rx_p.expression_numeric = sympy.lambdify(input_parameter_names, fromNamesToVariables(str(self.covariances_PM_simplified.V_p_nomod_Rx_p.expression_symbolic)))

        self.covariances_PM_simplified.C_q_mod_Rx_q.expression_symbolic = sympy.sqrt(T_q*eta/T_Tx)*2*n_q
        self.covariances_PM_simplified.C_q_mod_Rx_q.expression_numeric = sympy.lambdify(input_parameter_names, fromNamesToVariables(str(self.covariances_PM_simplified.C_q_mod_Rx_q.expression_symbolic)))    

        self.covariances_PM_simplified.C_p_mod_Rx_p.expression_symbolic = sympy.sqrt(T_p*eta/T_Tx)*2*n_p
        self.covariances_PM_simplified.C_p_mod_Rx_p.expression_numeric = sympy.lambdify(input_parameter_names, fromNamesToVariables(str(self.covariances_PM_simplified.C_p_mod_Rx_p.expression_symbolic)))


    
    def computeCovarianceMatrixPM(self, form='symbolic', print_warnings=False):
        """
        This function constructs the prepare & measure covariance matrix
    
        INPUTS
        ----------
        mode : string
            'symbolic' or 'numeric'
        print_warnings : boolean
            If True, sanity check warnings on the covariance matrix are printed 
            after the calculation.
        
        OUTPUTS:
        -------
        CM : 2D array-like of float
            The prepare & measure covariance matrix. The modes of the field are ordered as follows:
                
                1. Rx-q: Signal mode at the input of the receiver's homodyne detector 'q'';
                2. Rx-p: Signal mode at the input of the receiver's homodyne detector 'p'';
        """
        #------------------------------------------
        if form=='symbolic':
            CM = vacuum_symbolic(4)
            #Load all the QKD parameters into shorter-named variables
            attribute = 'symbol'
            [T_Tx, eta, tau_Rx, R_Rx, tau_q, tau_p, t_q, t_p, V_s, V_a, n_q, n_p, w_q, w_p] = \
             [getattr(self.parameters.T_Tx, attribute), getattr(self.parameters.eta, attribute),\
             getattr(self.parameters.tau_Rx, attribute), getattr(self.parameters.R_Rx, attribute),\
             getattr(self.parameters.tau_q, attribute), getattr(self.parameters.tau_p, attribute),\
             getattr(self.parameters.t_q, attribute),\
             getattr(self.parameters.t_p, attribute), getattr(self.parameters.V_s, attribute),\
             getattr(self.parameters.V_a, attribute), getattr(self.parameters.n_q, attribute),\
             getattr(self.parameters.n_p, attribute),
             getattr(self.parameters.w_q, attribute), getattr(self.parameters.w_p, attribute)]
            #Compute the variance of the squeezed (antisqueezed) quadrature and the mean photon number of the thermal state generated by 
            #the modulation, at the output of the displacement stage
            V_s_0 = (V_s-(1-T_Tx))/(T_Tx)
            n_q_0 = n_q/T_Tx
            n_p_0 = n_p/T_Tx
            V_a_0 = (V_a-(1-T_Tx))/(T_Tx)
            #--------------------------------------------
            #Initialize the covariance matrix in a vacuum state
            #-------------------------------
            #-------------------------------
            #Define the Gaussian-modulated single mode squeezed vacuum state
            #----------------------------------
            CM[0, 0] = V_a_0+2*n_q_0
            CM[1, 1] = V_s_0+2*n_p_0
            #---------------------------------
            #--------------------------------------
            #Propagate the signal to the channel input
            #-------------------------------------
            CM = CM.opticalefficiency(T_Tx, 1, 1, 1)
            CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
            #--------------------------------------
            #Define the asymmetric EPR state prepared by the eavesdropper
            #------------------------------------------------------
            c_1 = ((2*w_q+1)**2-1)**0.5 #inter-quadrature correlation 
            c_2 = ((2*w_p+1)**2-1)**0.5 #inter-quadrature correlation
            CM[2, 2] = CM[4, 4] = 2*w_q+1 #variance of the 'q' quadrature
            CM[3, 3] = CM[5, 5] = 2*w_p+1 #variance of the 'p' quadrature
            CM[2, 4] = CM[4, 2] = c_1 
            CM[3, 5] = CM[5, 3] = -c_2
            #-----------------------------------------------------
            #Interfere the first eavesdropper's mode and the propagating signal mode on the channel
            #------------------------------
            CM = CM.pick_modes(2, 1, 3, 4)
            CM = CM.bs(1, 2, R=1-eta)
            CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
            #discard the second eavesdropper's mode and the one propagating to the eavesdropper's measurement device    
            #and re-order the modes
            CM = CM.pick_modes(1, 4) 
            #-----------------------------
            #Propagate the signal toward the input of the receiver's beam splitter
            #------------------------------
            CM = CM.opticalefficiency(tau_Rx, 1)
            CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
            #-------------------------------
            #Split the signal at the receiver's beam splitter
            #The first split mode propagates towards the receiver's homodyne detector measuring 𝑝,
            #The second goes towards the homodyne detector measuring 𝑞
            #---------------------------------
            CM = CM.pick_modes(2, 1)
            CM = CM.bs(1, 2, R=R_Rx)
            CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
            CM = CM.pick_modes(2, 1)
            #--------------------------------
            #Propagate the receiver signals towards the respective homodyne detectors
            #------------------------------------------    
            #q
            CM = CM.opticalefficiency(tau_q, 1)
            CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
            CM[0, 0] += 2*t_q
            CM[1, 1] += 2*t_q
            #p
            CM = CM.opticalefficiency(1, tau_p)
            CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
            CM[2, 2] += 2*t_p
            CM[3, 3] += 2*t_p
            #-----------------------------------------
            CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
            self.covariance_matrix_PM.expression_symbolic = CM
            #Construct a matrix of python functions associated with the expression of the 
            #entries of the covariance matrix
            parameter_names = list(vars(self.parameters).keys())
            parameter_names.sort()
            CM_numeric = np.empty((2, 2), dtype=object)
            for j in range(2):
                for k in range(2):
                        CM_numeric[j, k] = sympy.lambdify(parameter_names, fromNamesToVariables(str(CM[j, k])))
            self.covariance_matrix_PM.expression_numeric = CM_numeric
        else:
            if self.covariance_matrix_PM.expression_symbolic is None:
                self.computeCovarianceMatrixPM(form='symbolic')
            parameter_values = [p.value for p in self.parameters.toList()]
            CM = np.zeros((2, 2))
            for j in range(2):
                for k in range(2):
                    CM[j, k] = self.covariance_matrix_PM.expression_numeric(*parameter_values)
        return CM
    
    
    def computeCovarianceMatrixPMClassical(self, form='symbolic', include_phase_noise=False, print_warnings=False):
        """
        This function constructs the prepare & measure classical covariance matrix.
    
         INPUTS
        ----------
        form : string
            'symbolic' or 'numeric'
            
        include_phase_noise : boolean
            If true, Gaussian phase noise at the receiver side is included in the 
            calculation. 
        
        print_warnings : boolean
            If True, sanity check warnings on the covariance matrix are printed 
            after the calculation.
        
        OUTPUTS:
        -------
        CM : 2D array-like of float
            The prepare & measure covariance matrix. The modes of the field are ordered as follows:
                1. Rx-q: Signal mode at the input of the receiver's homodyne detector 'q'';
                2. Rx-p: Signal mode at the input of the receiver's homodyne detector 'p'';
                3. mod: classical mode describing the Gaussian-distributed QKD symbols;
        """
        attribute = None
        if form=='symbolic':
            CM = vacuum_symbolic(5)
            attribute = 'symbol'
             #Load all the QKD parameters into shorter-named variables
            [T_Tx, eta, tau_Rx, R_Rx, tau_q, tau_p, t_q, t_p, V_s, V_a, n_q, n_p, w_q, w_p] = \
             [getattr(self.parameters.T_Tx, attribute), getattr(self.parameters.eta, attribute),\
             getattr(self.parameters.tau_Rx, attribute), getattr(self.parameters.R_Rx, attribute),\
             getattr(self.parameters.tau_q, attribute), getattr(self.parameters.tau_p, attribute),\
             getattr(self.parameters.t_q, attribute),\
             getattr(self.parameters.t_p, attribute), getattr(self.parameters.V_s, attribute),\
             getattr(self.parameters.V_a, attribute), getattr(self.parameters.n_q, attribute),\
             getattr(self.parameters.n_p, attribute),
             getattr(self.parameters.w_q, attribute), getattr(self.parameters.w_p, attribute)]
            #Compute the variance of the squeezed (antisqueezed) quadrature and the mean photon number of the thermal state generated by 
            #the modulation, at the output of the displacement stage
            V_s_0 = (V_s-(1-T_Tx))/(T_Tx)
            n_q_0 = n_q/T_Tx
            n_p_0 = n_p/T_Tx
            V_a_0 = (V_a-(1-T_Tx))/(T_Tx)
            #-------------------------------
            #Define the covariance matrix of the QKD symbols as the last mode
            #-------------------------------
            CM[8, 8] = 2*n_q_0
            CM[9, 9] = 2*n_p_0
            #Introduce correlations between the modulated signal mode and the QKD symbols
            CM[0, 8] = CM[8, 0] = 2*n_q_0
            CM[1, 9] = CM[9, 1] = 2*n_p_0       
            #-------------------------------
            #Define the Gaussian-modulated single mode squeezed vacuum state
            #----------------------------------
            CM[0, 0] = V_a_0 + 2*n_q_0
            CM[1, 1] = V_s_0 + 2*n_p_0
            #Propagate the reflected signal to the channel input
            #-------------------------------------
            CM = CM.opticalefficiency(T_Tx, 1, 1, 1, 1)
            CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
            #--------------------------------------
            #Define the asymmetric EPR state prepared by the eavesdropper
            #------------------------------------------------------
            c_1 = ((2*w_q+1)**2-1)**0.5 #inter-quadrature correlation 
            c_2 = ((2*w_p+1)**2-1)**0.5 #inter-quadrature correlation
            CM[2, 2] = CM[4, 4] = 2*w_q+1 #variance of the 'q' quadrature
            CM[3, 3] = CM[5, 5] = 2*w_p+1 #variance of the 'p' quadrature
            CM[2, 4] = CM[4, 2] = c_1 
            CM[3, 5] = CM[5, 3] = -c_2
            #-----------------------------------------------------
            #nterfere the first eavesdropper's mode and the propagating signal mode on the channel
            #------------------------------
            CM = CM.pick_modes(2, 1, 3, 4, 5)
            CM = CM.bs(1, 2, R=1-eta)
            CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
            #discard the second eavesdropper's mode and the one propagating to the eavesdropper's measurement device    
            #and re-order the modes
            CM = CM.pick_modes(1, 4, 5) 
            #-----------------------------
            #Propagate the signal toward the input of the receiver's beam splitter
            #------------------------------
            CM = CM.opticalefficiency(tau_Rx, 1, 1)
            CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
            #-------------------------------
            #Split the signal at the receiver's beam splitter
            #The first split mode propagates towards the receiver's homodyne detector measuring 𝑝,
            #The second goes towards the homodyne detector measuring 𝑞
            #---------------------------------
            CM = CM.pick_modes(2, 1, 3)
            CM = CM.bs(1, 2, R=R_Rx)
            CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
            CM = CM.pick_modes(2, 1, 3)
            #--------------------------------
            #Propagate the receiver signals towards the respective homodyne detectors
            #------------------------------------------
            #q
            CM = CM.opticalefficiency(tau_q, 1, 1)
            CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
            CM[0, 0] += 2*t_q
            CM[1, 1] += 2*t_q
            #p
            CM = CM.opticalefficiency(1, tau_p, 1)
            CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
            CM[2, 2] += 2*t_p
            CM[3, 3] += 2*t_p
            #-----------------------------------------
            #Include phase noise
            sigma_phi_Rx = self.parameters.sigma_phi_Rx.symbol
            phi_Rx = Parameter(name='\phi_{Rx}').symbol
            if include_phase_noise:
                #Apply a single rotation
                CM = CM.rotate(phi_Rx, phi_Rx, 0)
                #Integrate over all the possible rotations, assuming a zero-mean Gaussian distribution
                #of phase rotations
                PDF_phi = 1/sympy.sqrt(2*sympy.pi*sigma_phi_Rx**2) * sympy.exp(-phi_Rx**2/(2*sigma_phi_Rx**2))
                CM = sympy.integrate(CM*PDF_phi, (phi_Rx, -sympy.oo, sympy.oo), conds='none')
                CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
                
            self.covariance_matrix_PM_classical.expression_symbolic =  CM
            #Set the prepare & measure covariances
            setattr(self.covariances_PM.V_q_Rx_q, attribute, CM[0, 0])
            setattr(self.covariances_PM.V_q_nomod_Rx_q, attribute, CM[0, 0].subs([(n_q, 0)]))
            setattr(self.covariances_PM.V_p_nomod_Rx_p, attribute, CM[3, 3].subs([(n_p, 0)]))
            setattr(self.covariances_PM.V_q_Rx_p, attribute, CM[2, 2])
            setattr(self.covariances_PM.V_p_Rx_p, attribute, CM[3, 3])      
            setattr(self.covariances_PM.C_q_mod_Rx_q, attribute, CM[0, 4])
            setattr(self.covariances_PM.C_p_mod_Rx_p, attribute, CM[3, 5]) 
            #Construct a matrix of python functions associated with the expression of the 
            #entries of the covariance matrix
            parameter_names = list(vars(self.parameters).keys())
            parameter_names.sort()
            CM_numeric = np.empty((3, 3), dtype=object)
            for j in range(3):
                for k in range(3):
                        CM_numeric[j, k] = sympy.lambdify(parameter_names, fromNamesToVariables(str(CM[j, k])))
            self.covariance_matrix_PM.expression_numeric = CM_numeric
        else:
            if self.covariance_matrix_PM_classical.expression_symbolic is None:
                self.computeCovarianceMatrixPMClassical(form='symbolic')
            parameter_values = [p.value for p in self.parameters.toList()]
            CM = np.zeros((3, 3))
            for j in range(3):
                for k in range(3):
                    CM[j, k] = self.covariance_matrix_PM_classical.expression_numeric(*parameter_values)
        return CM
    
   
    def computeCovarianceMatrixEB(self, form='symbolic', print_warnings=False):
        """
        This function constructs the entanglement-based covariance matrix
        
        INPUTS
        ----------
        mode : string
            'symbolic' or 'numeric'
        print_warnings : boolean
            If True, sanity check warnings on the covariance matrix are printed 
            after the calculation.
             
        OUTPUTS:
        -------
        CM : 2D array-like of float
            The entanglement-based covariance matrix. The modes of the field are ordered as follows:
                1. B: signal mode propagating towards the receiver's homodyne detector p;
                2. E_1: first eavesdropper's mode, not interferring on the channel;
                3. E_2: second eavesdropper's mode, after interference with the signal on the channel;
        """
              #------------------------------------------
        if form=='symbolic':
            attribute = 'symbol'
            CM = vacuum_symbolic(4)
             #Load all the QKD parameters into shorter-named variables
            [T_Tx, eta, tau_Rx, R_Rx, tau_p, t_p, V_s, V_a, n_q, n_p, w_q, w_p] = \
             [getattr(self.parameters.T_Tx, attribute), getattr(self.parameters.eta, attribute),\
             getattr(self.parameters.tau_Rx, attribute), getattr(self.parameters.R_Rx, attribute),\
             getattr(self.parameters.tau_p, attribute),\
             getattr(self.parameters.t_p, attribute), getattr(self.parameters.V_s, attribute),\
             getattr(self.parameters.V_a, attribute), getattr(self.parameters.n_q, attribute),\
             getattr(self.parameters.n_p, attribute),
             getattr(self.parameters.w_q, attribute), getattr(self.parameters.w_p, attribute)]
            #Compute the variance of the squeezed (antisqueezed) quadrature and the mean photon number of the thermal state generated by 
            #the modulation, at the output of the displacement stage
            V_s_0 = sympy.symbols('V_{s_0}', real=True, nonnegative=True)
            V_a_0 = sympy.symbols('V_{a_0}', real=True, nonnegative=True)
            n_q_0 = sympy.symbols('n_{q_0}', real=True, nonnegative=True)
            n_p_0 = sympy.symbols('n_{p_0}', real=True, nonnegative=True)
            #define the two-mode squeezed state at the transmitter
            mu_q = sympy.symbols('\mu_q', real=True, nonnegative=True)
            mu_p = sympy.symbols('\mu_p', real=True, nonnegative=True)
            r = sympy.symbols('r', real=True, nonnegative=True)
            V_epsilon = sympy.symbols('V_\epsilon', real=True, nonnegative=True) #variance of the excess noise on the antisqueezed quadrature, due to imperfect squeezing
            CM[0, 0] = CM[2, 2] = mu_q
            CM[1, 1] = CM[3, 3] = mu_p 
            CM[2, 0] = CM[0, 2] = sympy.sqrt(mu_q**2-1)
            CM[3, 1] = CM[1, 3] = -sympy.sqrt(mu_p**2-1)    
            #Squeeze one mode of the two-mode squeezed state
            CM = CM.squeeze(0, -r, 0, 0) 
            CM[2, 2] += V_epsilon
            CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
            #Construct the first equation used to derive the entanglement-based parameters 
            #from the prepare & measure ones
            eq_1 = sympy.Eq(CM[3, 3], V_s_0+2*n_p_0) #the modulated squeezed quadrature variance is obtained after squeezing
            eq_2 = sympy.Eq(CM[2, 2], V_a_0+2*n_q_0) #the modulated antisqueezed quadrature variance is obtained after squeezing
            #Perform heterodyne detection on the first mode of the transmitter
            CM = CM.heterodyne_detection(1)
            CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
            #Construct the other equations
            eq_3 = sympy.Eq(CM[1, 1], V_s_0) #a single-mode squeezed stete is obtained after heterodyne detection
            eq_4 = sympy.Eq(CM[0, 0], V_a_0) #a single-mode squeezed stete is obtained after heterodyne detection
            #Solve the system of equations for the entanglement-based parameters
            solutions = sympy.solve([eq_1, eq_2, eq_3, eq_4], (mu_q, mu_p, r, V_epsilon), dict=True)[0]
            #substitute the solutions into the covariance matrix
            CM = CM.subs([(mu_q, sympy.simplify(solutions[mu_q])), \
                          (mu_p, sympy.simplify(solutions[mu_p])), \
                          (r, sympy.simplify(solutions[r])), \
                          (V_epsilon, sympy.simplify(solutions[V_epsilon]))])
            CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
            #Reintroduce the excess preparation noise in the antisqueezed quadrature
            CM[0, 0] = V_a_0
            #Construct the asymmetric two-mode squeezed state prepared by the eavesdropper
            c_1 = sympy.sqrt((2*w_q+1)**2-1)
            c_2 = sympy.sqrt((2*w_p+1)**2-1) 
            CM = CovarianceMatrix_symbolic(CM)          
            CM[2:6, 2:6] = [[2*w_q+1, 0, c_1, 0], [0, 2*w_p+1, 0, -c_2], [c_1, 0, 2*w_q+1, 0], [0, -c_2, 0, 2*w_p+1]]
            #Propagate the squeezed signal to the channel input
            CM = CM.opticalefficiency(T_Tx, 1, 1)
            CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
            #Re-order the modes for convenience in further beam splitting operations
            CM = CM.pick_modes(2, 3, 1)
            #Interfere the squeezed signal with the second eavesdropper's mode on the channel
            CM = CM.bs(2, 3, R=1-eta)
            CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
            #Propagate the squeezed signal from the channel output to the p homodyne detector input
            #Re-order the modes as follows:
            #1. B: signal mode propagating towards the receiver's homodyne detector p;
            #2. E_1: first eavesdropper's mode, not interferring on the channel;
            #3. E_2: second eavesdropper's mode, after interference with the signal on the channel;
            CM = CM.pick_modes(3, 1, 2)
            #Propagate the squeezed signal from the channel output to the homodyne detector input
            CM = CM.opticalefficiency(tau_Rx*(1-R_Rx)*tau_p, 1, 1)
            CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
            #Include the trusted homodyne detector noise
            CM[0, 0] += 2*t_p
            CM[1, 1] += 2*t_p
            #Express the prepare & measure source parameters at the modulation stage as functions
            #of the ones at the input of the channel
            CM = CM.subs([(V_s_0, (V_s-(1-T_Tx))/(T_Tx)), (V_a_0, (V_a-(1-T_Tx))/(T_Tx)), (n_q_0, n_q/(T_Tx)), (n_p_0, n_p/(T_Tx))]) 
            self.covariance_matrix_EB.expression_symbolic = CM
            #Construct a matrix of python functions associated with the expression of the 
            #entries of the covariance matrix
            parameter_names = list(vars(self.parameters).keys())
            parameter_names.sort()
            CM_numeric = np.empty((3, 3), dtype=object)
            for j in range(3):
                for k in range(3):
                        CM_numeric[j, k] = sympy.lambdify(parameter_names, fromNamesToVariables(str(CM[j, k])))
            self.covariance_matrix_EB.expression_numeric = CM_numeric
        else:
            if self.covariance_matrix_EB.expression_symbolic is None:
                self.computeCovarianceMatrixEB(form='symbolic')
            parameter_values = [p.value for p in self.parameters.toList()]
            CM = np.zeros((3, 3))
            for j in range(3):
                for k in range(3):
                    CM[j, k] = self.covariance_matrix_EB.expression_numeric(*parameter_values)
        return CM
    

    def keyRate(self, form='symbolic', print_warnings=False):
        """
        This function calculates the secret key rate from the entanglement-based covariance matrix.
        
        INPUTS
        ----------
        print_warnings: boolean
            If 'True', the function will print eventual warnings regarding the calculations. 
        
        OUTPUTS:
        -------
        The value of the secret key rate of the system : float 
        """
        if form=='symbolic':
            #Load all the QKD parameters into shorter-named variables
            #Load the needed variances and covariances
            [n_q, n_p] = [self.parameters.n_q.symbol, self.parameters.n_p.symbol]
            V_p_Rx_p, C_p_mod_Rx_p = [self.covariances_PM.V_p_Rx_p.expression_symbolic, self.covariances_PM.C_p_mod_Rx_p.expression_symbolic]
            V_q_Rx_q, C_q_mod_Rx_q = [self.covariances_PM.V_q_Rx_q.expression_symbolic, self.covariances_PM.C_q_mod_Rx_q.expression_symbolic]
            beta = self.beta.symbol
            #Compute the Shannon's mutual information of the modulated (squeezed) signal quadrature measured at the receiver's homodyne detector 'p' 
            #and the modulation signal (QKD symbols) prepared at the transmitter 
            I_AB = QIUtils.mutualInformation(variance_1=V_p_Rx_p, variance_2=2*n_p, covariance=C_p_mod_Rx_p) #[bit]
            I_AB += QIUtils.mutualInformation(variance_1=V_q_Rx_q, variance_2=2*n_q, covariance=C_q_mod_Rx_q)
            #Compute the entanglement-based covariance matrix of the system
            CM_EB = self.covariance_matrix_EB.expression_symbolic
            CM_E = CM_EB[2:6,2:6]
            #Under the assumption that the entangling cloner is the optimal strategy for the eavesdropper, it is sufficient to consider
            #only the eavesdropper's modes and the receiver's mode
            #Compute the entanglement-based covariance matrix after homodyne detection of the receiver's mode, along the 'p' quadrature
            CM_E_HD_B = CM_EB.homodyne_detection(1, 'p')
            if print_warnings and CM_E_HD_B.physicality<0:
                print("\nWarning in keyRate(): the entanglement-based covariance matrix after homodyne detection of the receiver's mode is unphysical.")
            #Compute the von Neumann entropy of the quantum states described by the covariance matrix with and without homodyne detection at the receiver
            S_E = QIUtils.VonNeumannEntropy(CM_E, print_warnings=print_warnings) #without homodyne detection
            S_E_HD_B = QIUtils.VonNeumannEntropy(CM_E_HD_B, print_warnings=print_warnings) #with homodyne detection
            #Compute the Holevo information
            Chi_EB = S_E - S_E_HD_B
            
            #Compute the secret key rate
            R = beta*I_AB - Chi_EB
            R = sympy.simplify(R)
            self.secret_key_rate.expression_symbolic = R 
        return R 
    

        
    def estimateParameters(self, parameter_names=None, covariance_names = None, \
                           form='symbolic', configuration='real transmission', minimal=True):
        """
        This function performs parameter estimation of the parameters specified by
        
        Parameters
        ----------
        parameter_names : array-like of string
            The names of the parameters to be estimated, in variables format (e.g., ['eta'])
        covariance_names : array-like of string
            The names of the quadrature covariances from which the parameters are to be estimated, in variable format (e.g., ['V_q_Tx'])
        mode : string
            'symbolc' 'numeric'. The default is 'symbolic'.
        configuration : string
        
            -'back-to-back': estimation of the QKD parameters without quantum channel
            
            -'real transmission': estimation of the QKD parameters with a quantum channel 
            
            The default is 'real transmission'.
        
        minimal : boolean
            If True, then parameter estimation is performed by considering the simplified
            expressions for the prepare & measure covariances, where the trusted losses are
            grouped into T_Tx, T_A, T_p and T_q.

        Returns
        -------
        None.

        """

        #Load the target parameters
        if parameter_names is None:
            raise ParameterEstimationError('No parameters were specified.')  
        equations_specified = covariance_names is not None
        #Load the prepare & measure covariances as parameters
        parameter_names.sort()
        covariance_names.sort()
        parameters = [getattr(self.parameters, name) for name in parameter_names]
        #Load the known parameteres
        known_parameter_names = [name for name in list(vars(self.parameters).keys()) if name not in parameter_names+['eta', 'w_q', 'w_p']]
        known_parameter_names.sort()
        known_parameters = [getattr(self.parameters, name) for name in known_parameter_names]
        analytical_expression_missing = sum([p.expression_symbolic is None for p in parameters]) > 0
        #Check for possible errors in the input
        if not(equations_specified) and analytical_expression_missing:
            raise ParameterEstimationError("Analytical expressions of the parameters to be estimated are not available, but prepare & measure covariances were not specified."\
                                           +"\n You need to specify the covariances which parameters are estimated from.")
        if minimal:
            covariances= [getattr(self.covariances_PM_simplified, name) for name in covariance_names]
        else:     
            covariances= [getattr(self.covariances_PM, name) for name in covariance_names]
        #Symbolic parameter estimation 
        if form=='symbolic':
            #Set up the system of equations for estimating parameters
            system = []
            for covariance in covariances:
                if configuration=='back-to-back':
                    system.append(sympy.Eq(covariance.expression_symbolic.subs([(self.parameters.eta.symbol, 1)]), covariance.symbol))
                else:
                    system.append(sympy.Eq(covariance.expression_symbolic, covariance.symbol))
            system = tuple(system)
            parameter_symbols = [p.symbol for p in parameters]
            #Solve the system of equations
            try:
                solutions = sympy.solve(system, tuple(parameter_symbols), dict=True)[0]
            except:
                raise ParameterEstimationError('No solution was found')
            #Set the symbolic expressions into the QKD system
            for solution_symbol in list(solutions.keys()):
                parameter = [p for p in parameters if p.name==solution_symbol.name][0]
                parameter.expression_symbolic = solutions[solution_symbol]
                parameter.expression_numeric = sympy.lambdify(known_parameter_names+covariance_names, fromNamesToVariables(str(solutions[solution_symbol])))  
        else: 
            if analytical_expression_missing:
                self.estimateParameters(parameter_names=parameter_names, covariance_names=covariance_names, form='symbolic', configuration=configuration)
            #Load the known parameters as symbols or values
            known_parameters = [p.value for p in known_parameters]
            #Load the prepare & measure covariances as symbols or values
            covariances = [c.value for c in covariances]
            for parameter in parameters:
                parameter.value = parameter.expression_numeric(*(known_parameters+covariances))
                        
#%%    
def fromNamesToVariables(string_symbols):
    """
    This function converts a string containing a symbolic expression
    into a string corresponding to the same Python expression with names of variables. 
    """
    return string_symbols.replace('^{(', '_').replace(')}', '').replace('Tx/', 'Tx_')\
            .replace('mod/', 'mod_')\
            .replace('{', '').replace('}', '').replace('Rx-', 'Rx_').replace('\\', '')\
            .replace('Tx_q', 'q_Tx').replace('Rx_q_q', 'q_Rx_q').replace('Rx_p_q', 'q_Rx_p')\
            .replace('Rx_p_p', 'p_Rx_p').replace('Rx_p(nomod', 'nomod_Rx_p').replace('Rx_q(nomod', 'nomod_Rx_q')\
            .replace('mod_p', 'p_mod') .replace('mod_q', 'q_mod')  
#%%
#Define exceptions
class ParameterEstimationError(Exception):
    def __init__(self, error_message):
        print(error_message)
        