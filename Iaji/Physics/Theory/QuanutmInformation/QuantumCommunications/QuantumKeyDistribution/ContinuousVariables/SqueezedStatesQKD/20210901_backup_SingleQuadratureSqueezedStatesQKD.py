"""
This file defines classes that describe a QKD system, specifically 
a QKD system based on the Gaussian modulation of the squeezed quadrature of a bosonic field.
"""

#%%
#Imports
import numpy as np
import sympy
sympy.init_printing()
from Iaji.Physics.Theory.QuanutmInformation import QuantumInformationUtilities as QIUtils
from quik.qip.nmodes import vacuum
from quik.qip.nmodes_symbolic import Vacuum as vacuum_symbolic
from quik.qip.nmodes_symbolic import CovarianceMatrix as CovarianceMatrix_symbolic
#%%
class Parameter:
    """
    This class describes a generic parameter. A parameter is described by the following properties:
        -name
        
        -symbol
        
        -value: the numerical value of the parameter
        
        -expression_symbolic: a symbolic mathematical expression of the parameter, in terms of other symbols
       
        -expression_numeric: a function that allows numerical evaluation of the parameter's value form numerical input parameters
    """
    
    def __init__(self, name='x', value=None, real=True, nonnegative=True):
        self.name = name
        self.value = value
        self.symbol = sympy.symbols(names=name, real=real, nonnegative=nonnegative)
        self.expression_symbolic = None
        self.expression_numeric = None
#%%
class QKDParameters:
    """
    This class describes the parameters of the QKD system:
        
    - n: real, > 0.

         mean photon number of the thermal state generated by Gaussian modulation of a displaced vacuum state, at the output of the squeezer
    - V_s$ real, > 0.

        variance of the squeezed quadrature of the unmodulated signal, at the output of the squeezer
    
    - \tau_s: real, [0, 1]
        
        power transmission efficiency of the squeezer and the modulator
        
    - R_{Tx}: real, [0, 1]

        power reflectivity of the transmitter/channel beam splitter.  

    - \tau_{Tx}: real, [0, 1]

            power transmission efficiency from the reflection port of the transmitter/channel beam splitter to the channel input.

    - \tau_A: real, [0, 1]

        power transmission efficiency from the transmission port of the transmitter/channel beam splitter to the transmitter's homodyne detector (including photodiodes' quantum efficiency).

    - t_A: real, > 0

        mean photon number corresponding to the thermal noise added by the transmitter's homodyne detector.

    - w_q, w_p: real, > 0

        mean photon number of the excess thermal noise in the state prepared by the entangling cloner, at the channel input
    
    - u_q,p = w_q,p*(1-eta)
        mean photon number of the excess thermal noise in the state prepared by the entangling cloner, at the channel output
        
    - \eta: real, [0, 1]

        power transmission efficiency of the quantum channel.

    - \tau_{Rx}: real, [0, 1]

        power transmission efficiency from the channel's output to the receiver's beam splitter input.

    - \tau_q, \tau_p: real, [0, 1]

        power transmission efficiency from the output of the receiver's beam splitter to the input of the receiver's homodyne detector, measuring q, p.

    - t_q, t_p: real, > 0

        mean photon number corresponding to the thermal noise added by homodyne detectors Rx-q and Rx-p
    
    - R_{Rx}: real, [0, 1]

        power reflectivity of the receiver's beam splitter.
        
    - \sigma_{\phi_{Tx}}: real, > 0
        standard deviation of the Gaussian phase noise from the transmitter's local oscillaltor
        
    - \sigma_{\phi_{Rx}}: real, > 0
        standard deviation of the Gaussian phase noise from the receiver's local oscillaltor
    
    - \theta_c : real, [-pi, pi]
        angle of the first phase rotation induced by an unknown channel, described by a general one-mode Gaussian transformation
    
    - r_c : real, > 0
        squeezing parameter, of squeezing induced by an unknown channel, described by a general one-mode Gaussian transformation
        
    - \phi_c : real, [-pi, pi]
        angle of the second phase rotation induced by an unknown channel, described by a general one-mode Gaussian transformation
    
    - T_Tx: real, [0, 1]
        Auxiliary parameter, equal to \tau_{Tx}*R_{Tx}
    
    - T_A: real, [0, 1]
        Auxiliary parameter, equal to R_{Tx}*\tau_A
    
    - T_q: real, [0, 1]
        Auxiliary parameter, equal to \tau_{Rx}*R_{Rx}*tau_q
    
    - T_p: real, [0, 1]
        Auxiliary parameter, equal to \tau_{Rx}*(1-R_{Rx})*tau_p
    """      
    
    def __init__(self, tau_s=None, R_Tx=None, tau_Tx=None, tau_A=None, t_A=None, \
                 eta=None, tau_Rx=None,  R_Rx=None, tau_q=None, t_q=None, tau_p=None,\
                 t_p=None, V_s=None, n=None, w_q=None, w_p=None, sigma_phi_Tx=None, sigma_phi_Rx=None,\
                 theta_c=None, r_c=None, phi_c=None):
        self.tau_s = Parameter(name='\\tau_s', value=tau_s) 
        self.R_Tx = Parameter(name='R_{Tx}', value=R_Tx)
        self.tau_Tx = Parameter(name='\\tau_{Tx}', value=tau_Tx)
        self.tau_A = Parameter(name='\\tau_A', value=tau_A)
        self.t_A = Parameter(name='t_A', value=t_A)
        self.eta = Parameter(name='\\eta', value=eta)
        self.tau_Rx = Parameter(name='\\tau_{Rx}', value=tau_Rx)
        self.R_Rx = Parameter(name='R_{Rx}', value=R_Rx)
        self.tau_q = Parameter(name='\\tau_q', value=tau_q)
        self.t_q = Parameter(name='t_q', value=t_q)
        self.tau_p = Parameter(name='\\tau_p', value=tau_q)
        self.t_p = Parameter(name='t_p', value=t_p)
        self.V_s = Parameter(name='V_s', value=V_s)
        self.n = Parameter(name='n', value=n)
        self.w_q = Parameter(name='w_q', value=w_q)
        self.w_p = Parameter(name='w_p', value=w_p)
        value = None
        if w_q:
            value = w_q*(1-eta)
        self.u_q = Parameter(name='u_q', value=value)
        if w_p:
            value = w_p*(1-eta)
        self.u_p = Parameter(name='u_p', value=value)
        self.sigma_phi_Tx = Parameter(name='\\sigma_{\\phi_{Tx}}', value=sigma_phi_Tx, nonnegative=False)
        self.sigma_phi_Rx = Parameter(name='\\sigma_{\\phi_{Rx}}', value=sigma_phi_Rx, nonnegative=False) 
        self.theta_c = Parameter(name='\\theta_c', value=theta_c, nonnegative=False)
        self.r_c = Parameter(name='r_c', value=r_c, nonnegative=False)
        self.phi_c = Parameter(name='\\phi_c', value=phi_c, nonnegative=False)
        #Define auxiliary parameters used for minimal complete parameter estimation
        #Transmission efficiency from the input of the transmitter/channel beam splitter to the input of the channel
        if R_Tx is None or tau_Tx is None:
            value = None
        else:
            value = tau_s*R_Tx*tau_Tx
        self.T_Tx = Parameter(name='T_{Tx}', value=value)
        #self.T_Tx.expression_symbolic = self.R_Tx.symbol*self.tau_Tx.symbol
        #Transmission efficiency from the input of the transmitter/channel beam splitter to the input of homodyne detector Tx
        if R_Tx is None or tau_Tx is None:
            value = None
        else:
            value = tau_s*(1-R_Tx)*tau_A
        self.T_A = Parameter(name='T_A', value=value)
        #self.T_A.expression_symbolic = (1-self.R_Tx.symbol)*self.tau_A.symbol   
        #Transmission efficiency from the output of the channel to the input of homodyne detector Rx-q
        if R_Rx is None or tau_Rx is None:
            value = None
        else:
            value = tau_Rx*R_Rx*tau_q
        self.T_q = Parameter(name='T_q', value=value)
        #self.T_q.expression_symbolic = self.tau_Rx.symbol*self.R_Rx.symbol*self.tau_q.symbol   
        #Transmission efficiency from the output of the channel to the input of homodyne detector Rx-p
        if R_Rx is None or tau_Rx is None:
            value = None
        else:
            value = tau_Rx*(1-R_Rx)*tau_p
        self.T_p = Parameter(name='T_p', value=value)
        #self.T_p.expression_symbolic = self.tau_Rx.symbol*(1-self.R_Rx.symbol)*self.tau_p.symbol
        
    def toList(self):
        """
        This function returns a list of all the QKD parameters, ordered by their name
        """
        dictionary = vars(self)
        dictionary_sorted = dict(sorted(dictionary.items(), key=lambda item: item[0]))
        return list(dictionary_sorted.values())  
    
    def toDict(self, attribute='name'):
        """
        This function returns a dictionary of all the QKD parameters, with keys given
        by the parameter attribute 'attribute'.
        
        INPUTS
        ------------------
        attribute : string
            The attribute used as key to the dictionary. Refer to Parameter class for the attributes.
        """
        
        parameters = self.toList() 
        attributes = [getattr(p, attribute) for p in parameters]
        return dict(zip(attributes, parameters))
        

#%%
class QKDPrepareAndMeasureCovariances:
    """
    This class defines the entries of the prepare & measure covariance
    matrix of the QKD system, relevant to experimental parameter estimation:
        
        - V^{(Tx)}_q: variance of the q quadrature detected at homodomdyne detector Tx

        - V^{(Rx-q)}_q: variance of the q quadrature detected at homodomdyne detector Rx-q

        - V^{(Rx-p)}_q: variance of the q quadrature detected at homodomdyne detector Rx-p

        - V^{(Rx-p)}_p: variance of the p quadrature detected at homodomdyne detector Rx-p

        - V^{(Rx-p)}_{p(nomod)}: variance of the p quadrature detected at homodomdyne detector Rx-p without modulation ($n=0$)

        - C^{(Tx/Rx-q)}_q: covariance between the q quadratures detected at homodyne detectors Tx and Rx-q

        - C^{(Tx/Rx-p)}_q: covariance between the q quadratures detected at homodyne detectors Tx and Rx-p

        - C^{(mod/Rx-p)}_p: covariance between the p quadrature detected at homodyne detector Rx-p and the generated QKD symbols

    """

    def __init__(self, V_q_Tx=None, V_q_Rx_q=None, V_q_Rx_p=None, V_p_Rx_p=None,\
                 V_p_nomod_Rx_p=None, C_q_Tx_Rx_q=None, C_q_Tx_Rx_p=None,\
                 C_p_mod_Rx_p=None):
        self.V_q_Tx = Parameter(name='V^{(Tx)}_q', value=V_q_Tx)
        self.V_q_Rx_q = Parameter(name='V^{(Rx-q)}_q', value=V_q_Rx_q)
        self.V_q_Rx_p = Parameter(name='V^{(Rx-p)}_q', value=V_q_Rx_p)
        self.V_p_Rx_p = Parameter(name='V^{(Rx-p)}_p', value=V_p_Rx_p)
        self.V_p_nomod_Rx_p = Parameter(name='V^{(Rx-p)}_{p(nomod)}', value=V_p_nomod_Rx_p)
        self.C_q_Tx_Rx_q = Parameter(name='C^{(Tx/Rx-q)}_q', value=C_q_Tx_Rx_q )
        self.C_q_Tx_Rx_p = Parameter(name='C^{(Tx/Rx-p)}_q', value=C_q_Tx_Rx_p)
        self.C_p_mod_Rx_p = Parameter(name='C^{(mod/Rx-p)}_p', value=C_p_mod_Rx_p)
    
    def toList(self):
        """
        This function returns a list of all the QKD parameters, ordered by their name
        """
        dictionary = vars(self)
        dictionary_sorted = dict(sorted(dictionary.items(), key=lambda item: item[0]))
        return list(dictionary_sorted.values())     
    
#%%+
class QKDSystem:
    """
    This class describes a QKD system, which has the following properties:
        - A set of QKD parameters
        - A prepare & measure covariance matrix (quantum mechanical and classical)
        - An entanglement-based covariance matrix
        - An error correction efficiency
        - A set of experimentally measured covariances, i.e., entries of the prepare & measure classical covariance matrix
        - A secret key rate
    
    The class allows to perform the following tasks:
        - Compute the covariance matrices associated to the system, given QKD parameters (symbolically and numerically)
        - Perform parameter estimation (symbolically and numerically)
        - Estimate the secret key rate (numerically)
        
    The vacuum quadrature variance is assumed to be equal to 1. All quadrature covariances are 
    normalized to the vacuum quadrature variance.
    """    
    
    def __init__(self, parameters=QKDParameters(), covariances_PM=QKDPrepareAndMeasureCovariances(), \
                 error_correction_efficiency=1):
        self.parameters = parameters #QKD parameters
        self.covariances_PM = covariances_PM #prepare and measure covariances
        
        self.covariance_matrix_PM = Parameter(name='\Sigma_{PM}', value=None, nonnegative=False) #prepare & measure covariance matrix
        self.computeCovarianceMatrixPM()
        
        self.covariance_matrix_PM_classical = Parameter(name='\Sigma_{PM(classical)}', value=None, nonnegative=False) #prepare & measure classical covariance matrix
        self.computeCovarianceMatrixPMClassical()
        
        self.covariance_matrix_EB = Parameter(name='\Sigma_{EB}', value=None, nonnegative=False) #entanglement-based covariance matrix
        self.computeCovarianceMatrixEB()
        
        self.beta = Parameter(name='\\beta') #error correction efficiency [adimensional, in [0, 1]]
        self.secret_key_rate = Parameter(name='R', real=True, nonnegative=False) #secret key rate [bit/symbol]
         
        #Construct a set of simplified prepare & measure covariances, derived by hand
        self.covariances_PM_simplified = QKDPrepareAndMeasureCovariances()
        #Assign symbolic and numeric expressions
        T_A = self.parameters.T_A.symbol
        T_Tx = self.parameters.T_Tx.symbol
        eta = self.parameters.eta.symbol
        T_q = self.parameters.T_q.symbol
        T_p = self.parameters.T_p.symbol
        t_A = self.parameters.t_A.symbol
        t_q = self.parameters.t_q.symbol
        t_p = self.parameters.t_p.symbol
        V_s = self.parameters.V_s.symbol
        n = self.parameters.n.symbol
        w_q = self.parameters.w_q.symbol
        w_p = self.parameters.w_p.symbol
        
        input_parameter_names = ['T_A', 'T_Tx', 'eta', 'T_q', 'T_p', 't_A', 't_q', 't_p', 'V_s', 'n' 'w_q', 'w_p']
        input_parameter_names.sort()
        
        self.covariances_PM_simplified.V_q_Tx.expression_symbolic = T_A*(1/V_s-1) + 2*t_A + 1
        self.covariances_PM_simplified.V_q_Tx.expression_numeric = sympy.lambdify(input_parameter_names, fromNamesToVariables(str(self.covariances_PM_simplified.V_q_Tx.expression_symbolic)))
        
        self.covariances_PM_simplified.V_q_Rx_q.expression_symbolic = T_q*(T_Tx*eta*(1/V_s-1)+2*w_q*(1-eta))+ 2*t_q + 1
        self.covariances_PM_simplified.V_q_Rx_q.expression_numeric = sympy.lambdify(input_parameter_names, fromNamesToVariables(str(self.covariances_PM_simplified.V_q_Rx_q.expression_symbolic)))

        
        self.covariances_PM_simplified.V_q_Rx_p.expression_symbolic = T_p*(T_Tx*eta*(1/V_s-1)+2*w_q*(1-eta)) + 2*t_p + 1
        self.covariances_PM_simplified.V_q_Rx_p.expression_numeric = sympy.lambdify(input_parameter_names, fromNamesToVariables(str(self.covariances_PM_simplified.V_q_Rx_p.expression_symbolic)))

        
        self.covariances_PM_simplified.V_p_Rx_p.expression_symbolic = T_p*(T_Tx*eta*(V_s+2*n-1)+2*w_p*(1-eta)) + 2*t_p + 1
        self.covariances_PM_simplified.V_p_Rx_p.expression_numeric = sympy.lambdify(input_parameter_names, fromNamesToVariables(str(self.covariances_PM_simplified.V_p_Rx_p.expression_symbolic)))

        
        self.covariances_PM_simplified.V_p_nomod_Rx_p.expression_symbolic = self.covariances_PM_simplified.V_p_Rx_p.expression_symbolic.subs([(n, 0)])
        self.covariances_PM_simplified.V_p_nomod_Rx_p.expression_numeric = sympy.lambdify(input_parameter_names, fromNamesToVariables(str(self.covariances_PM_simplified.V_p_nomod_Rx_p.expression_symbolic)))

        
        self.covariances_PM_simplified.C_q_Tx_Rx_q.expression_symbolic = sympy.sqrt(T_A*T_Tx*T_q*eta)*(1/V_s-1)
        self.covariances_PM_simplified.C_q_Tx_Rx_q.expression_numeric = sympy.lambdify(input_parameter_names, fromNamesToVariables(str(self.covariances_PM_simplified.C_q_Tx_Rx_q.expression_symbolic)))

        
        self.covariances_PM_simplified.C_q_Tx_Rx_p.expression_symbolic = sympy.sqrt(T_A*T_Tx*T_p*eta)*(1/V_s-1)
        self.covariances_PM_simplified.C_q_Tx_Rx_p.expression_numeric = sympy.lambdify(input_parameter_names, fromNamesToVariables(str(self.covariances_PM_simplified.C_q_Tx_Rx_p.expression_symbolic)))

        
        self.covariances_PM_simplified.C_p_mod_Rx_p.expression_symbolic = sympy.sqrt(T_Tx*T_p*eta)*2*n
        self.covariances_PM_simplified.C_p_mod_Rx_p.expression_numeric = sympy.lambdify(input_parameter_names, fromNamesToVariables(str(self.covariances_PM_simplified.C_p_mod_Rx_p.expression_symbolic)))
        
        
        tau_s = self.parameters.tau_s.symbol
        R_Tx = self.parameters.R_Tx.symbol
        tau_A = self.parameters.tau_A.symbol
        tau_Tx = self.parameters.tau_Tx.symbol
        tau_Rx = self.parameters.tau_Rx.symbol
        R_Rx = self.parameters.R_Rx.symbol
        tau_q = self.parameters.tau_q.symbol
        tau_p = self.parameters.tau_p.symbol
        
        input_parameter_names = ['tau_s', 'R_Tx', 'tau_A', 'tau_Tx', 'eta', 'tau_Rx', 'R_Rx', 'tau_q','tau_p', 't_A', 't_q', 't_p', 'V_s', 'n' 'w_q', 'w_p']
        input_parameter_names.sort()
        
        for name in list(vars(self.covariances_PM).keys()):
            covariance = getattr(self.covariances_PM, name)
            covariance_simplified = getattr(self.covariances_PM_simplified, name)
            covariance.expression_symbolic = \
                covariance_simplified.expression_symbolic.subs([(T_A, tau_s*(1-R_Tx)*tau_A), \
                                                                (T_Tx, tau_s*R_Tx*tau_Tx),\
                                                                (T_q, tau_Rx*R_Rx*tau_q),\
                                                                (T_p, tau_Rx*R_Rx*tau_p)])
            covariance.expression_numeric = sympy.lambdify(input_parameter_names, fromNamesToVariables(str(covariance.expression_symbolic)))
            setattr(self.covariances_PM, name, covariance)
        
    def computeCovarianceMatrixPM(self, form='symbolic', print_warnings=False):
        """
        This function constructs the prepare & measure covariance matrix
    
        INPUTS
        ----------
        mode : string
            'symbolic' or 'numeric'
        print_warnings : boolean
            If True, sanity check warnings on the covariance matrix are printed 
            after the calculation.
        
        OUTPUTS:
        -------
        CM : 2D array-like of float
            The prepare & measure covariance matrix. The modes of the field are ordered as follows:
                1. Tx: Signal mode at the input of the transmitter's homodyne detector
                2. Rx-q: Signal mode at the input of the receiver's homodyne detector 'q'';
                3. Rx-p: Signal mode at the input of the receiver's homodyne detector 'p'';
        """
        #------------------------------------------
        if form=='symbolic':
            attribute = 'symbol'
            CM = vacuum_symbolic(5)
        else:
            attribute = 'value'
            CM = vacuum(5)
        #Load all the QKD parameters into shorter-named variables
        [tau_s, R_Tx, tau_A, tau_Tx, eta, tau_Rx, R_Rx, tau_q, tau_p, t_A, t_q, t_p, V_s, n, w_q, w_p] = \
         [getattr(self.parameters.tau_s, attribute), getattr(self.parameters.R_Tx, attribute), getattr(self.parameters.tau_A, attribute),\
         getattr(self.parameters.tau_Tx, attribute), getattr(self.parameters.eta, attribute),\
         getattr(self.parameters.tau_Rx, attribute), getattr(self.parameters.R_Rx, attribute),\
         getattr(self.parameters.tau_q, attribute), getattr(self.parameters.tau_p, attribute),\
         getattr(self.parameters.t_A, attribute), getattr(self.parameters.t_q, attribute),\
         getattr(self.parameters.t_p, attribute), getattr(self.parameters.V_s, attribute),\
         getattr(self.parameters.n, attribute),\
         getattr(self.parameters.w_q, attribute), getattr(self.parameters.w_p, attribute)]
        #--------------------------------------------
        #Initialize the covariance matrix in a vacuum state
        #-------------------------------
        #-------------------------------
        #Define the Gaussian-modulated single mode squeezed vacuum state
        #----------------------------------
        CM[0, 0] = 1/V_s
        CM[1, 1] = V_s + 2*n
        CM = CovarianceMatrix_symbolic(CM)
        CM = CM.opticalefficiency(tau_s, 1, 1, 1, 1)
        #Re-order the modes for convenience with beam splitting operations
        CM = CM.pick_modes(2, 1, 3, 4, 5)
        #---------------------------------
        #Split the signal mode between the channel and the transmitter's homodyne detector
        #The first split mode propagates towards the transmitter's homodyne detector. The second goes towards the channel.
        #----------------------------------
        CM = CM.bs(1, 2, R=R_Tx)
        CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
        #----------------------------------
        #Propagate the signal towards the transmitter's homodyne detector
        #-------------------------------------
        CM = CM.opticalefficiency(tau_A, 1, 1, 1, 1)
        CM = CovarianceMatrix_symbolic(sympy.simplify(CM))      
        CM[0, 0] += 2*t_A #detector noise
        CM[1, 1] += 2*t_A #detector noise
        #--------------------------------------
        #Propagate the reflected signal to the channel input
        #-------------------------------------
        CM = CM.opticalefficiency(1, tau_Tx, 1, 1, 1)
        CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
        #Exchange the order of the modes for convenience with beam splitting operations
        CM = CM.pick_modes(1, 3, 4, 2, 5)
        #--------------------------------------
        #Define the asymmetric EPR state prepared by the eavesdropper
        #------------------------------------------------------
        c_1 = ((2*w_q+1)**2-1)**0.5 #inter-quadrature correlation 
        c_2 = ((2*w_p+1)**2-1)**0.5 #inter-quadrature correlation
        CM[2, 2] = CM[4, 4] = 2*w_q+1 #variance of the 'q' quadrature
        CM[3, 3] = CM[5, 5] = 2*w_p+1 #variance of the 'p' quadrature
        CM[2, 4] = CM[4, 2] = c_1 
        CM[3, 5] = CM[5, 3] = -c_2
        #-----------------------------------------------------
        #nterfere the first eavesdropper's mode and the propagating signal mode on the channel
        #------------------------------
        CM = CM.bs(2, 4, R=1-eta)
        CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
        #discard the second eavesdropper's mode and the one propagating to the eavesdropper's measurement device    
        #and re-order the modes
        CM = CM.pick_modes(1, 5, 2) 
        #-----------------------------
        #Propagate the signal toward the input of the receiver's beam splitter
        #------------------------------
        CM = CM.opticalefficiency(1, 1, tau_Rx)
        CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
        #-------------------------------
        #Split the signal at the receiver's beam splitter
        #The first split mode propagates towards the receiver's homodyne detector measuring 𝑝,
        #The second goes towards the homodyne detector measuring 𝑞
        #---------------------------------
        CM = CM.bs(2, 3, R=R_Rx)
        CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
        #--------------------------------
        #Propagate the receiver signals towards the respective homodyne detectors
        #------------------------------------------
        #q
        CM = CM.opticalefficiency(1, 1, tau_q)
        CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
        CM[4, 4] += 2*t_q
        CM[5, 5] += 2*t_q
        #p
        CM = CM.opticalefficiency(1, tau_p, 1)
        CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
        CM[2, 2] += 2*t_p
        CM[3, 3] += 2*t_p
        #Re-order the modes
        CM = CM.pick_modes(1, 3, 2)
        #-----------------------------------------
        #Construct a matrix of python functions associated with the expression of the 
        #entries of the covariance matrix
        parameter_names = list(vars(self.parameters).keys())
        parameter_names.sort()
        CM_numeric = np.empty((3, 3), dtype=object)
        for j in range(3):
            for k in range(3):
                    CM_numeric[j, k] = sympy.lambdify(parameter_names, fromNamesToVariables(str(CM[j, k])))
        self.covariance_matrix_PM.expression_numeric = CM_numeric
        
        if form=='symbolic':
            attribute = 'expression_symbolic'
            CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
        setattr(self.covariance_matrix_PM, attribute, CM)
        return CM
    
    
    def computeCovarianceMatrixPMClassical(self, form='symbolic', include_phase_noise=False, print_warnings=False):
        """
        This function constructs the prepare & measure classical covariance matrix.
    
         INPUTS
        ----------
        mode : string
            'symbolic' or 'numeric'
        print_warnings : boolean
            If True, sanity check warnings on the covariance matrix are printed 
            after the calculation.
        
        OUTPUTS:
        -------
        CM : 2D array-like of float
            The prepare & measure covariance matrix. The modes of the field are ordered as follows:
                1. Tx: Signal mode at the input of the transmitter's homodyne detector
                2. Rx-q: Signal mode at the input of the receiver's homodyne detector 'q'';
                3. Rx-p: Signal mode at the input of the receiver's homodyne detector 'p'';
                4. mod: classical mode describing the Gaussian-distributed QKD symbols;
        """
        attribute = None
        if form=='symbolic':
            attribute = 'symbol'
            CM = vacuum_symbolic(6)
        else:
            attribute = 'value'
            CM = vacuum(6)
        #Load all the QKD parameters into shorter-named variables
        [tau_s, R_Tx, tau_A, tau_Tx, eta, tau_Rx, R_Rx, tau_q, tau_p, t_A, t_q, t_p, V_s, n, w_q, w_p] = \
         [getattr(self.parameters.tau_s, attribute), getattr(self.parameters.R_Tx, attribute), getattr(self.parameters.tau_A, attribute),\
         getattr(self.parameters.tau_Tx, attribute), getattr(self.parameters.eta, attribute),\
         getattr(self.parameters.tau_Rx, attribute), getattr(self.parameters.R_Rx, attribute),\
         getattr(self.parameters.tau_q, attribute), getattr(self.parameters.tau_p, attribute),\
         getattr(self.parameters.t_A, attribute), getattr(self.parameters.t_q, attribute),\
         getattr(self.parameters.t_p, attribute), getattr(self.parameters.V_s, attribute),\
         getattr(self.parameters.n, attribute),\
         getattr(self.parameters.w_q, attribute), getattr(self.parameters.w_p, attribute)]
        #Compute the variance of the squeezed (antisqueezed) quadrature and the mean photon number of the thermal state generated by 
        #the modulation, at the output of the displacement stage
        #-------------------------------
        #Define the covariance matrix of the QKD symbols as the last mode
        #-------------------------------
        CM[10, 10] = 0
        CM[11, 11] = 2*n
        #Introduce correlations between the modulated signal mode and the QKD symbols
        CM[1, 11] = CM[11, 1] = 2*n
        #-------------------------------
        #Define the Gaussian-modulated single mode squeezed vacuum state
        #----------------------------------
        CM[0, 0] = 1/V_s
        CM[1, 1] = V_s+2*n
        CM = CovarianceMatrix_symbolic(CM)
        CM = CM.opticalefficiency(tau_s, 1, 1, 1, 1, 1)
        #Re-order the modes for convenience with beam splitting operations
        CM = CM.pick_modes(2, 1, 3, 4, 5, 6)
        #---------------------------------
        #Split the signal mode between the channel and the transmitter's homodyne detector
        #The first split mode propagates towards the transmitter's homodyne detector. The second goes towards the channel.
        #----------------------------------
        CM = CM.bs(1, 2, R=R_Tx)
        CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
        #----------------------------------
        #Propagate the signal towards the transmitter's homodyne detector
        #-------------------------------------
        CM = CM.opticalefficiency(tau_A, 1, 1, 1, 1, 1)
        CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
        CM[0, 0] += 2*t_A #detector noise
        CM[1, 1] += 2*t_A #detector noise
        #--------------------------------------
        #Propagate the reflected signal to the channel input
        #-------------------------------------
        CM = CM.opticalefficiency(1, tau_Tx, 1, 1, 1, 1)
        CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
        #Exchange the order of the modes for convenience with beam splitting operations
        CM = CM.pick_modes(1, 3, 4, 2, 5, 6)
        #--------------------------------------
        #Define the asymmetric EPR state prepared by the eavesdropper
        #------------------------------------------------------
        c_1 = ((2*w_q+1)**2-1)**0.5 #inter-quadrature correlation 
        c_2 = ((2*w_p+1)**2-1)**0.5 #inter-quadrature correlation
        CM[2, 2] = CM[4, 4] = 2*w_q+1 #variance of the 'q' quadrature
        CM[3, 3] = CM[5, 5] = 2*w_p+1 #variance of the 'p' quadrature
        CM[2, 4] = CM[4, 2] = c_1 
        CM[3, 5] = CM[5, 3] = -c_2
        #-----------------------------------------------------
        #nterfere the first eavesdropper's mode and the propagating signal mode on the channel
        #------------------------------
        CM = CM.bs(2, 4, R=1-eta)
        CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
        #discard the second eavesdropper's mode and the one propagating to the eavesdropper's measurement device    
        #and re-order the modes
        CM = CM.pick_modes(1, 5, 2, 6) 
        #-----------------------------
        #Propagate the signal toward the input of the receiver's beam splitter
        #------------------------------
        CM = CM.opticalefficiency(1, 1, tau_Rx, 1)
        CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
        #-------------------------------
        #Split the signal at the receiver's beam splitter
        #The first split mode propagates towards the receiver's homodyne detector measuring 𝑝,
        #The second goes towards the homodyne detector measuring 𝑞
        #---------------------------------
        CM = CM.bs(2, 3, R=R_Rx)
        CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
        #--------------------------------
        #Propagate the receiver signals towards the respective homodyne detectors
        #------------------------------------------
        #q
        CM = CM.opticalefficiency(1, 1, tau_q, 1)
        CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
        CM[4, 4] += 2*t_q
        CM[5, 5] += 2*t_q
        #p
        CM = CM.opticalefficiency(1, tau_p, 1, 1)
        CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
        CM[2, 2] += 2*t_p
        CM[3, 3] += 2*t_p
        #Re-order the modes
        CM = CM.pick_modes(1, 3, 2, 4)
        #-----------------------------------------
        #Include phase noise
        sigma_phi_Rx = self.parameters.sigma_phi_Rx.symbol
        phi_Rx = Parameter(name='\phi_{Rx}').symbol
        if include_phase_noise:
            #Apply a single rotation
            CM = CM.rotate(0, phi_Rx, phi_Rx, 0)
            #Integrate over all the possible rotations, assuming a zero-mean Gaussian distribution
            #of phase rotations
            PDF_phi = 1/sympy.sqrt(2*sympy.pi*sigma_phi_Rx**2) * sympy.exp(-phi_Rx**2/(2*sigma_phi_Rx**2))
            CM = sympy.integrate(CM*PDF_phi, (phi_Rx, -sympy.oo, sympy.oo), conds='none')
            CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
        #Construct a matrix of python functions associated with the expression of the 
        #entries of the covariance matrix
        parameter_names = list(vars(self.parameters).keys())
        parameter_names.sort()
        CM_numeric = np.empty((4, 4), dtype=object)
        for j in range(4):
            for k in range(4):
                    CM_numeric[j, k] = sympy.lambdify(parameter_names, fromNamesToVariables(str(CM[j, k])))
        self.covariance_matrix_PM.expression_numeric = CM_numeric
        
        if form=='symbolic':
            attribute = 'expression_symbolic'
            CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
        setattr(self.covariance_matrix_PM_classical, attribute, CM)
        #Set the prepare & measure covariances
        setattr(self.covariances_PM.V_q_Tx, attribute, CM[0, 0])
        setattr(self.covariances_PM.V_q_Rx_q, attribute, CM[2, 2])
        setattr(self.covariances_PM.V_q_Rx_p, attribute, CM[4, 4])
        setattr(self.covariances_PM.V_p_Rx_p, attribute, CM[5, 5])
        setattr(self.covariances_PM.V_p_nomod_Rx_p, attribute, CM[5, 5].subs([(n, 0)]))
        setattr(self.covariances_PM.C_q_Tx_Rx_q, attribute, CM[0, 2])
        setattr(self.covariances_PM.C_q_Tx_Rx_p, attribute, CM[0, 4])
        setattr(self.covariances_PM.C_p_mod_Rx_p, attribute, CM[5, 7])
        
        return CM
    
    
    def computeCovarianceMatrixPMClassical2(self, form='symbolic', include_phase_noise=False, print_warnings=False):
        """
        This function constructs the prepare & measure classical covariance matrix.
    
         INPUTS
        ----------
        mode : string
            'symbolic' or 'numeric'
        print_warnings : boolean
            If True, sanity check warnings on the covariance matrix are printed 
            after the calculation.
        
        OUTPUTS:
        -------
        CM : 2D array-like of float
            The prepare & measure covariance matrix. The modes of the field are ordered as follows:
                1. Tx: Signal mode at the input of the transmitter's homodyne detector
                2. Rx-q: Signal mode at the input of the receiver's homodyne detector 'q'';
                3. Rx-p: Signal mode at the input of the receiver's homodyne detector 'p'';
                4. mod: classical mode describing the Gaussian-distributed QKD symbols;
        """
        attribute = None
        if form=='symbolic':
            attribute = 'symbol'
            CM = vacuum_symbolic(4)
        else:
            attribute = 'value'
            CM = vacuum(4)
        #Load all the QKD parameters into shorter-named variables
        [tau_s, R_Tx, tau_A, tau_Tx, theta_c, r_c, phi_c, tau_Rx, R_Rx, tau_q, tau_p, t_A, t_q, t_p, V_s, n, w_q, w_p] = \
         [getattr(self.parameters.tau_s, attribute), getattr(self.parameters.R_Tx, attribute), getattr(self.parameters.tau_A, attribute),\
         getattr(self.parameters.tau_Tx, attribute), getattr(self.parameters.theta_c, attribute),\
         getattr(self.parameters.r_c, attribute), getattr(self.parameters.phi_c, attribute),   
         getattr(self.parameters.tau_Rx, attribute), getattr(self.parameters.R_Rx, attribute),\
         getattr(self.parameters.tau_q, attribute), getattr(self.parameters.tau_p, attribute),\
         getattr(self.parameters.t_A, attribute), getattr(self.parameters.t_q, attribute),\
         getattr(self.parameters.t_p, attribute), getattr(self.parameters.V_s, attribute),\
         getattr(self.parameters.n, attribute),\
         getattr(self.parameters.w_q, attribute), getattr(self.parameters.w_p, attribute)]
        #Compute the variance of the squeezed (antisqueezed) quadrature and the mean photon number of the thermal state generated by 
        #the modulation, at the output of the displacement stage
        #-------------------------------
        #Define the covariance matrix of the QKD symbols as the last mode
        #-------------------------------
        CM[6, 6] = 0
        CM[7, 7] = 2*n
        #Introduce correlations between the modulated signal mode and the QKD symbols
        CM[1, 7] = CM[7, 1] = 2*n
        #-------------------------------
        #Define the Gaussian-modulated single mode squeezed vacuum state
        #----------------------------------
        CM[0, 0] = 1/V_s
        CM[1, 1] = V_s+2*n
        CM = CovarianceMatrix_symbolic(CM)
        CM = CM.opticalefficiency(tau_s, 1, 1, 1)
        #Re-order the modes for convenience with beam splitting operations
        CM = CM.pick_modes(2, 1, 3, 4)
        #---------------------------------
        #Split the signal mode between the channel and the transmitter's homodyne detector
        #The first split mode propagates towards the transmitter's homodyne detector. The second goes towards the channel.
        #----------------------------------
        CM = CM.bs(1, 2, R=R_Tx)
        CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
        #----------------------------------
        #Propagate the signal towards the transmitter's homodyne detector
        #-------------------------------------
        CM = CM.opticalefficiency(tau_A, 1, 1, 1)
        CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
        CM[0, 0] += 2*t_A #detector noise
        CM[1, 1] += 2*t_A #detector noise
        #--------------------------------------
        #Propagate the reflected signal to the channel input
        #-------------------------------------
        CM = CM.opticalefficiency(1, tau_Tx, 1, 1)
        CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
        #Model the channel as the most general one-mode Gaussian transformation
        CM = CM.rotate(0, phi_c, 0, 0).squeeze(0, r_c, 0, 0).rotate(0, theta_c, 0, 0)
        #-----------------------------
        #Propagate the signal toward the input of the receiver's beam splitter
        #------------------------------
        CM = CM.opticalefficiency(1, tau_Rx, 1, 1)
        CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
        #-------------------------------
        #Split the signal at the receiver's beam splitter
        #The first split mode propagates towards the receiver's homodyne detector measuring 𝑝,
        #The second goes towards the homodyne detector measuring 𝑞
        #---------------------------------
        CM = CM.bs(2, 3, R=R_Rx)
        CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
        #--------------------------------
        #Propagate the receiver signals towards the respective homodyne detectors
        #------------------------------------------
        #q
        CM = CM.opticalefficiency(1, 1, tau_q, 1)
        CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
        CM[4, 4] += 2*t_q
        CM[5, 5] += 2*t_q
        #p
        CM = CM.opticalefficiency(1, tau_p, 1, 1)
        CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
        CM[2, 2] += 2*t_p
        CM[3, 3] += 2*t_p
        #Re-order the modes
        CM = CM.pick_modes(1, 3, 2, 4)
        #-----------------------------------------
        #Include phase noise
        sigma_phi_Rx = self.parameters.sigma_phi_Rx.symbol
        phi_Rx = Parameter(name='\phi_{Rx}').symbol
        if include_phase_noise:
            #Apply a single rotation
            CM = CM.rotate(0, phi_Rx, phi_Rx, 0)
            #Integrate over all the possible rotations, assuming a zero-mean Gaussian distribution
            #of phase rotations
            PDF_phi = 1/sympy.sqrt(2*sympy.pi*sigma_phi_Rx**2) * sympy.exp(-phi_Rx**2/(2*sigma_phi_Rx**2))
            CM = sympy.integrate(CM*PDF_phi, (phi_Rx, -sympy.oo, sympy.oo), conds='none')
            CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
        #Construct a matrix of python functions associated with the expression of the 
        #entries of the covariance matrix
        parameter_names = list(vars(self.parameters).keys())
        parameter_names.sort()
        CM_numeric = np.empty((4, 4), dtype=object)
        for j in range(4):
            for k in range(4):
                    CM_numeric[j, k] = sympy.lambdify(parameter_names, fromNamesToVariables(str(CM[j, k])))
        self.covariance_matrix_PM.expression_numeric = CM_numeric
        
        if form=='symbolic':
            attribute = 'expression_symbolic'
            CM = CovarianceMatrix_symbolic(sympy.simplify(CM))
        setattr(self.covariance_matrix_PM_classical, attribute, CM)
        #Set the prepare & measure covariances
        setattr(self.covariances_PM.V_q_Tx, attribute, CM[0, 0])
        setattr(self.covariances_PM.V_q_Rx_q, attribute, CM[2, 2])
        setattr(self.covariances_PM.V_q_Rx_p, attribute, CM[4, 4])
        setattr(self.covariances_PM.V_p_Rx_p, attribute, CM[5, 5])
        setattr(self.covariances_PM.V_p_nomod_Rx_p, attribute, CM[5, 5].subs([(n, 0)]))
        setattr(self.covariances_PM.C_q_Tx_Rx_q, attribute, CM[0, 2])
        setattr(self.covariances_PM.C_q_Tx_Rx_p, attribute, CM[0, 4])
        setattr(self.covariances_PM.C_p_mod_Rx_p, attribute, CM[5, 7])
        
        return CM
    
   
    def computeCovarianceMatrixEB(self, form='symbolic', print_warnings=False):
        """
        This function constructs the entanglement-based covariance matrix
        
        INPUTS
        ----------
        form : string
            'symbolic' or 'numeric'
        print_warnings : boolean
            If True, sanity check warnings on the covariance matrix are printed 
            after the calculation.
             
        OUTPUTS:
        -------
        CM : 2D array-like of float
            The entanglement-based covariance matrix. The modes of the field are ordered as follows:        
                1. A: signal mode at the transmitter homodyned detector
                2. B: signal mode at the receiver homodyne detector
        """
        #------------------------------------------
        attribute = 'symbol'
        [V_s, n, R_Tx, eta, R_Rx, t_p] = \
        [getattr(self.parameters.V_s, attribute), getattr(self.parameters.n, attribute),\
         getattr(self.parameters.R_Tx, attribute), \
         getattr(self.parameters.eta, attribute), getattr(self.parameters.R_Rx, attribute),\
         getattr(self.parameters.t_p, attribute)]
        CM = vacuum_symbolic(4)
        mu = sympy.symbols('mu', real=True, nonnegative=True)
        r = sympy.symbols('r', real=True, nonnegative=True)
        #Define the two-mode vacuum state at the transmitter
        #----------------
        CM = CM.epr_state(mode1=1, mode2=2, mu=mu)
        #Squeeze the second mode
        CM = CM.squeeze(0, -r, 0, 0)
        #Trusted loss at the transmitter
        CM = CM.bs(2, 3, R=R_Tx)
        #Propagation through the channel
        CM = CM.opticalefficiency(1, eta, 1, 1)
        #Trusted loss and noise
        CM = CM.bs(2, 4, R=R_Rx)
        CM = CM.pick_modes(1, 3, 2, 4)
        return CM
    def keyRate(self, method='purification assumption', print_warnings=False):
        """
        This function calculates the secret key rate from the entanglement-based covariance matrix.
        
        INPUTS
        ----------
        method : string
            Method used for calculating the secret key rate. Accepted values are:
                    - "purification assumption": the key rate is computed from the shared state between the trusted parties, assuming the eavesdropper's state purifies
                      the shared state. It is the most general assumption known so far.
        print_warnings: boolean
            If 'True', the function will print eventual warnings regarding the calculations. 
        
        OUTPUTS:
        -------
        The value of the secret key rate of the system : float 
        """
        if method=='purification assumption':
            #initialize the shared covariance matrix, containing the following modes:
                #A: one mode of the TMSV state prepared by the transmitter, kept by the latter
                #B: the mode being propagated towards the receiver's homodyne detector
                #C: one TMSV mode responsible for trusted loss at the transmitter, not propagating through the channel
                #
            pass
      
        return 
    

        
    def estimateParameters(self, parameter_names=None, covariance_names = None, \
                           form='symbolic', configuration='real transmission', minimal=True):
        """
        This function performs parameter estimation of the parameters specified by
        
        Parameters
        ----------
        parameter_names : array-like of string
            The names of the parameters to be estimated, in variables format (e.g., ['eta'])
        covariance_names : array-like of string
            The names of the quadrature covariances from which the parameters are to be estimated, in variable format (e.g., ['V_q_Tx'])
        mode : string
            'symbolc' 'numeric'. The default is 'symbolic'.
        configuration : string
        
            -'back-to-back': estimation of the QKD parameters without quantum channel
            
            -'real transmission': estimation of the QKD parameters with a quantum channel 
            
            The default is 'real transmission'.
        
        minimal : boolean
            If True, then parameter estimation is performed by considering the simplified
            expressions for the prepare & measure covariances, where the trusted losses are
            grouped into T_Tx, T_A, T_p and T_q.

        Returns
        -------
        None.

        """

        #Load the target parameters
        if parameter_names is None:
            raise ParameterEstimationError('No parameters were specified.')  
        equations_specified = covariance_names is not None
        #Load the prepare & measure covariances as parameters
        parameter_names.sort()
        covariance_names.sort()
        parameters = [getattr(self.parameters, name) for name in parameter_names]
        #Load the known parameteres
        known_parameter_names = [name for name in list(vars(self.parameters).keys()) if name not in parameter_names+['eta', 'w_q', 'w_p']]
        known_parameter_names.sort()
        known_parameters = [getattr(self.parameters, name) for name in known_parameter_names]
        analytical_expression_missing = sum([p.expression_symbolic is None for p in parameters]) > 0
        #Check for possible errors in the input
        if not(equations_specified) and analytical_expression_missing:
            raise ParameterEstimationError("Analytical expressions of the parameters to be estimated are not available, but prepare & measure covariances were not specified."\
                                           +"\n You need to specify the covariances which parameters are estimated from.")
        if minimal:
            covariances= [getattr(self.covariances_PM_simplified, name) for name in covariance_names]
        else:     
            covariances= [getattr(self.covariances_PM, name) for name in covariance_names]
        #Symbolic parameter estimation 
        if form=='symbolic':
            #Set up the system of equations for estimating parameters
            system = []
            for covariance in covariances:
                if configuration=='back-to-back':
                    system.append(sympy.Eq(covariance.expression_symbolic.subs([(self.parameters.eta.symbol, 1), (self.parameters.u_q.symbol, 0), (self.parameters.u_p.symbol, 0)]), covariance.symbol))
                else:
                    system.append(sympy.Eq(covariance.expression_symbolic, covariance.symbol))
            system = tuple(system)
            parameter_symbols = [p.symbol for p in parameters]
            #Solve the system of equations
            try:
                solutions = sympy.solve(system, tuple(parameter_symbols), dict=True)
                solutions = solutions[0]
            except:
                raise ParameterEstimationError('No solution was found')
            #Set the symbolic expressions into the QKD system
            for solution_symbol in list(solutions.keys()):
                parameter = [p for p in parameters if p.name==solution_symbol.name][0]
                parameter.expression_symbolic = solutions[solution_symbol]
                parameter.expression_numeric = sympy.lambdify(known_parameter_names+covariance_names, fromNamesToVariables(str(solutions[solution_symbol])))  
        else: 
            if analytical_expression_missing:
                self.estimateParameters(parameter_names=parameter_names, covariance_names=covariance_names, form='symbolic', configuration=configuration)
            #Load the known parameters as symbols or values
            known_parameters = [p.value for p in known_parameters]
            #Load the prepare & measure covariances as symbols or values
            covariances = [c.value for c in covariances]
            for parameter in parameters:
                parameter.value = parameter.expression_numeric(*(known_parameters+covariances))
                        
#%%    
def fromNamesToVariables(string_symbols):
    """
    This function converts a string containing a symbolic expression
    into a string corresponding to the same Python expression with names of variables. 
    """
    return string_symbols.replace('^{(', '_').replace(')}', '').replace('Tx/', 'Tx_')\
            .replace('mod/', 'mod_')\
            .replace('{', '').replace('}', '').replace('Rx-', 'Rx_').replace('\\', '')\
            .replace('Tx_q', 'q_Tx').replace('Rx_q_q', 'q_Rx_q').replace('Rx_p_q', 'q_Rx_p')\
            .replace('Rx_p_p', 'p_Rx_p').replace('Rx_p(nomod', 'nomod_Rx_p')\
            .replace('mod_p', 'p_mod')   
#%%
#Define exceptions
class ParameterEstimationError(Exception):
    def __init__(self, error_message):
        print(error_message)
        